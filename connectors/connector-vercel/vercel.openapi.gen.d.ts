/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/edge-config": {
    /**
     * Get Edge Configs
     * @description Returns all Edge Configs.
     */
    get: operations["getEdgeConfigs"];
    /**
     * Create an Edge Config
     * @description Creates an Edge Config.
     */
    post: operations["createEdgeConfig"];
  };
  "/edge-config/{edgeConfigId}": {
    /**
     * Get an Edge Config
     * @description Returns an Edge Config.
     */
    get: operations["getEdgeConfig"];
    /**
     * Update an Edge Config
     * @description Updates an Edge Config.
     */
    put: operations["updateEdgeConfig"];
    /**
     * Delete an Edge Config
     * @description Delete an Edge Config by id.
     */
    delete: operations["deleteEdgeConfig"];
  };
  "/edge-config/{edgeConfigId}/item/{edgeConfigItemKey}": {
    /**
     * Get an Edge Config item
     * @description Returns a specific Edge Config Item.
     */
    get: operations["getEdgeConfigItem"];
  };
  "/edge-config/{edgeConfigId}/items": {
    /**
     * Get Edge Config items
     * @description Returns all items of an Edge Config.
     */
    get: operations["getEdgeConfigItems"];
    /**
     * Update Edge Config items in batch
     * @description Update multiple Edge Config Items in batch.
     */
    patch: operations["patchtEdgeConfigItems"];
  };
  "/edge-config/{edgeConfigId}/token": {
    /**
     * Create an Edge Config token
     * @description Adds a token to an existing Edge Config.
     */
    post: operations["createEdgeConfigToken"];
  };
  "/edge-config/{edgeConfigId}/token/{token}": {
    /**
     * Get Edge Config token meta data
     * @description Return meta data about an Edge Config token.
     */
    get: operations["getEdgeConfigToken"];
  };
  "/edge-config/{edgeConfigId}/tokens": {
    /**
     * Get all tokens of an Edge Config
     * @description Returns all tokens of an Edge Config.
     */
    get: operations["getEdgeConfigTokens"];
    /**
     * Delete one or more Edge Config tokens
     * @description Deletes one or more tokens of an existing Edge Config.
     */
    delete: operations["deleteEdgeConfigTokens"];
  };
  "/registration": {
    /**
     * Login with email
     * @description Request a new login for a user to get a token. This will respond with a verification token and send an email to confirm the request. Once confirmed you can use the verification token to get an authentication token.
     */
    post: operations["emailLogin"];
  };
  "/registration/verify": {
    /**
     * Verify a login request to get an authentication token
     * @description Verify the user accepted the login request and get a authentication token. The user email address and the token received after requesting the login must be added to the URL as a query string with the names `email` and `token`.
     */
    get: operations["verifyToken"];
  };
  "/v1/deployments/{deploymentId}/checks": {
    /**
     * Retrieve a list of all checks
     * @description List all of the checks created for a deployment.
     */
    get: operations["getAllChecks"];
    /**
     * Creates a new Check
     * @description Creates a new check. This endpoint must be called with an OAuth2 or it will produce a 400 error.
     */
    post: operations["createCheck"];
  };
  "/v1/deployments/{deploymentId}/checks/{checkId}": {
    /**
     * Get a single check
     * @description Return a detailed response for a single check.
     */
    get: operations["getCheck"];
    /**
     * Update a check
     * @description Update an existing check. This endpoint must be called with an OAuth2 or it will produce a 400 error.
     */
    patch: operations["updateCheck"];
  };
  "/v1/deployments/{deploymentId}/checks/{checkId}/rerequest": {
    /**
     * Rerequest a check
     * @description Rerequest a selected check that has failed.
     */
    post: operations["rerequestCheck"];
  };
  "/v1/domains/records/{recordId}": {
    /**
     * Update an existing DNS record
     * @description Updates an existing DNS record for a domain name.
     */
    patch: operations["updateRecord"];
  };
  "/v1/integrations/configuration/{id}": {
    /**
     * Retrieve an integration configuration
     * @description Allows to retrieve a the configuration with the provided id in case it exists. The authenticated user or team must be the owner of the config in order to access it.
     */
    get: operations["getConfiguration"];
    /**
     * Delete an integration configuration
     * @description Allows to remove the configuration with the `id` provided in the parameters. The configuration and all of its resources will be removed. This includes Webhooks, LogDrains and Project Env variables.
     */
    delete: operations["deleteConfiguration"];
  };
  "/v1/integrations/configurations": {
    /**
     * Get configurations for the authenticated user or team
     * @description Allows to retrieve all configurations for an authenticated integration. When the `project` view is used, configurations generated for the authorization flow will be filtered out of the results.
     */
    get: operations["getConfigurations"];
  };
  "/v1/integrations/git-namespaces": {
    /**
     * List git namespaces by provider
     * @description Lists git namespaces for a supported connector. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider is not provided, it will try to obtain it from the user that authenticated the request.
     */
    get: operations["gitNamespaces"];
  };
  "/v1/integrations/log-drains/{id}": {
    /**
     * Deletes the Integration log drain with the provided `id`
     * @description Deletes the Integration log drain with the provided `id`. When using an OAuth2 Token, the log drain can be deleted only if the integration owns it.
     */
    delete: operations["deleteIntegrationLogDrain"];
  };
  "/v1/integrations/search-repo": {
    /**
     * List git repositories linked to namespace by provider
     * @description Lists git repositories linked to a namespace `id` for a supported connector. A specific namespace `id` can be obtained via the `git-namespaces`  endpoint. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider or namespace is not provided, it will try to obtain it from the user that authenticated the request.
     */
    get: {
      parameters: {
        query?: {
          query?: string;
          namespaceId?: string | number | null;
          provider?: "github" | "gitlab" | "bitbucket";
          installationId?: string;
          /** @description The Team identifier or slug to perform the request on behalf of. */
          teamId?: string;
        };
      };
      responses: {
        200: {
          content: {
            "application/json": {
              gitAccount: {
                namespaceId: string | number;
                /** @enum {string} */
                connector: "github" | "gitlab" | "bitbucket";
              };
              repos: ({
                  defaultBranch: string;
                  id: string | number;
                  name: string;
                  namespace: string;
                  /** @enum {string} */
                  ownerType: "team" | "user";
                  private: boolean;
                  slug: string;
                  updatedAt: number;
                  url: string;
                })[];
            };
          };
        };
        /** @description One of the provided values in the request query is invalid. */
        400: {
          content: never;
        };
        /** @description You do not have permission to access this resource. */
        403: {
          content: never;
        };
      };
    };
  };
  "/v1/log-drains": {
    /**
     * Retrieves a list of Configurable Log Drains
     * @description Retrieves a list of Configurable Log Drains. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be accessed.
     */
    get: operations["getConfigurableLogDrains"];
    /**
     * Creates a Configurable Log Drain
     * @description Creates a configurable log drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed)
     */
    post: operations["createConfigurableLogDrain"];
  };
  "/v1/log-drains/{id}": {
    /**
     * Retrieves a Configurable Log Drain
     * @description Retrieves a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be accessed.
     */
    get: operations["getConfigurableLogDrain"];
    /**
     * Deletes a Configurable Log Drain
     * @description Deletes a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be deleted.
     */
    delete: operations["deleteConfigurableLogDrain"];
  };
  "/v1/projects/{idOrName}/env/{id}": {
    /**
     * Retrieve the decrypted value of an environment variable of a project by id
     * @description Retrieve the environment variable for a given project.
     */
    get: operations["getProjectEnv"];
  };
  "/v1/teams": {
    /**
     * Create a Team
     * @description Create a new Team under your account. You need to send a POST request with the desired Team slug, and optionally the Team name.
     */
    post: operations["createTeam"];
  };
  "/v1/teams/{teamId}": {
    /**
     * Delete a Team
     * @description Delete a team under your account. You need to send a `DELETE` request with the desired team `id`. An optional array of reasons for deletion may also be sent.
     */
    delete: operations["deleteTeam"];
  };
  "/v1/teams/{teamId}/invites/{inviteId}": {
    /**
     * Delete a Team invite code
     * @description Delete an active Team invite code.
     */
    delete: operations["deleteTeamInviteCode"];
  };
  "/v1/teams/{teamId}/members": {
    /**
     * Invite a user
     * @description Invite a user to join the team specified in the URL. The authenticated user needs to be an `OWNER` in order to successfully invoke this endpoint. The user can be specified with an email or an ID. If both email and ID are provided, ID will take priority.
     */
    post: operations["inviteUserToTeam"];
  };
  "/v1/teams/{teamId}/members/teams/join": {
    /**
     * Join a team
     * @description Join a team with a provided invite code or team ID.
     */
    post: operations["joinTeam"];
  };
  "/v1/teams/{teamId}/members/{uid}": {
    /**
     * Remove a Team Member
     * @description Remove a Team Member from the Team, or dismiss a user that requested access, or leave a team.
     */
    delete: operations["removeTeamMember"];
    /**
     * Update a Team Member
     * @description Update the membership of a Team Member on the Team specified by `teamId`, such as changing the _role_ of the member, or confirming a request to join the Team for an unconfirmed member. The authenticated user must be an `OWNER` of the Team.
     */
    patch: operations["updateTeamMember"];
  };
  "/v1/teams/{teamId}/request": {
    /**
     * Request access to a team
     * @description Request access to a team as a member. An owner has to approve the request. Only 10 users can request access to a team at the same time.
     */
    post: operations["requestAccessToTeam"];
  };
  "/v1/teams/{teamId}/request/{userId}": {
    /**
     * Get access request status
     * @description Check the status of a join request. It'll respond with a 404 if the request has been declined. If no `userId` path segment was provided, this endpoint will instead return the status of the authenticated user.
     */
    get: operations["getTeamAccessRequest"];
  };
  "/v1/user": {
    /**
     * Delete User Account
     * @description Initiates the deletion process for the currently authenticated User, by sending a deletion confirmation email. The email contains a link that the user needs to visit in order to proceed with the deletion process.
     */
    delete: operations["requestDelete"];
  };
  "/v1/webhooks": {
    /**
     * Get a list of webhooks
     * @description Get a list of webhooks
     */
    get: operations["getWebhooks"];
    /**
     * Creates a webhook
     * @description Creates a webhook
     */
    post: operations["createWebhook"];
  };
  "/v1/webhooks/{id}": {
    /**
     * Get a webhook
     * @description Get a webhook
     */
    get: operations["getWebhook"];
    /**
     * Deletes a webhook
     * @description Deletes a webhook
     */
    delete: operations["deleteWebhook"];
  };
  "/v10/projects/{idOrName}/env": {
    /**
     * Create one or more environment variables
     * @description Create one ore more environment variables for a project by passing its `key`, `value`, `type` and `target` and by specifying the project by either passing the project `id` or `name` in the URL.
     */
    post: operations["createProjectEnv"];
  };
  "/v11/deployments/{deploymentId}/builds": {
    /**
     * List Deployment Builds
     * @description Retrieves the list of builds given their deployment's unique identifier.
     */
    get: operations["listDeploymentBuilds"];
  };
  "/v12/deployments/{id}/cancel": {
    /**
     * Cancel a deployment
     * @description This endpoint allows you to cancel a deployment which is currently building, by supplying its `id` in the URL.
     */
    patch: operations["cancelDeployment"];
  };
  "/v13/deployments": {
    /**
     * Create a new deployment
     * @description Create a new deployment with all the required and intended data. If the deployment is not a git deployment, all files must be provided with the request, either referenced or inlined. Additionally, a deployment id can be specified to redeploy a previous deployment.
     */
    post: operations["createDeployment"];
  };
  "/v13/deployments/{idOrUrl}": {
    /**
     * Get a deployment by ID or URL
     * @description Retrieves information for a deployment either by supplying its ID (`id` property) or Hostname (`url` property). Additional details will be included when the authenticated user is an owner of the deployment.
     */
    get: operations["getDeployment"];
  };
  "/v13/deployments/{id}": {
    /**
     * Delete a Deployment
     * @description This API allows you to delete a deployment, either by supplying its `id` in the URL or the `url` of the deployment as a query parameter. You can obtain the ID, for example, by listing all deployments.
     */
    delete: operations["deleteDeployment"];
  };
  "/v2/aliases/{aliasId}": {
    /**
     * Delete an Alias
     * @description Delete an Alias with the specified ID.
     */
    delete: operations["deleteAlias"];
  };
  "/v2/deployments/{idOrUrl}/events": {
    /**
     * Get deployment events
     * @description Get the build logs of a deployment by deployment ID and build ID. It can work as an infinite stream of logs or as a JSON endpoint depending on the input parameters.
     */
    get: operations["getDeploymentEvents"];
  };
  "/v2/deployments/{id}/aliases": {
    /**
     * List Deployment Aliases
     * @description Retrieves all Aliases for the Deployment with the given ID. The authenticated User must own the deployment.
     */
    get: operations["listDeploymentAliases"];
    /**
     * Assign an Alias
     * @description Creates a new alias for the deployment with the given deployment ID. The authenticated user must own this deployment. If the desired alias is already assigned to another deployment, then it will be removed from the old deployment and assigned to the new one.
     */
    post: operations["assignAlias"];
  };
  "/v2/domains/{domain}/records": {
    /**
     * Create a DNS record
     * @description Creates a DNS record for a domain.
     */
    post: operations["createRecord"];
  };
  "/v2/domains/{domain}/records/{recordId}": {
    /**
     * Delete a DNS record
     * @description Removes an existing DNS record from a domain name.
     */
    delete: operations["removeRecord"];
  };
  "/v2/files": {
    /**
     * Upload Deployment Files
     * @description Before you create a deployment you need to upload the required files for that deployment. To do it, you need to first upload each file to this endpoint. Once that's completed, you can create a new deployment with the uploaded files. The file content must be placed inside the body of the request. In the case of a successful response you'll receive a status code 200 with an empty body.
     */
    post: operations["uploadFile"];
  };
  "/v2/integrations/log-drains": {
    /**
     * Retrieves a list of Integration log drains
     * @description Retrieves a list of all Integration log drains that are defined for the authorized account. When using an OAuth2 token, the list is limited to log drains created by the authenticated integration.
     */
    get: operations["getIntegrationLogDrains"];
    /**
     * Creates a new Integration Log Drain
     * @description Creates an Integration log drain. This endpoint must be called with an OAuth2 client (integration), since log drains are tied to integrations. If it is called with a different token type it will produce a 400 error.
     */
    post: operations["createLogDrain"];
  };
  "/v2/secrets/{idOrName}": {
    /**
     * Delete a secret
     * @description This deletes the user's secret defined in the URL.
     */
    delete: operations["deleteSecret"];
  };
  "/v2/secrets/{name}": {
    /**
     * Create a new secret
     * @description Allows to create a new secret.
     */
    post: operations["createSecret"];
    /**
     * Change secret name
     * @description Enables to edit the name of a user's secret. The name has to be unique to that user's secrets.
     */
    patch: operations["renameSecret"];
  };
  "/v2/teams": {
    /**
     * List all teams
     * @description Get a paginated list of all the Teams the authenticated User is a member of.
     */
    get: operations["getTeams"];
  };
  "/v2/teams/{teamId}": {
    /**
     * Get a Team
     * @description Get information for the Team specified by the `teamId` parameter.
     */
    get: operations["getTeam"];
    /**
     * Update a Team
     * @description Update the information of a Team specified by the `teamId` parameter. The request body should contain the information that will be updated on the Team.
     */
    patch: operations["patchTeam"];
  };
  "/v2/teams/{teamId}/members": {
    /**
     * List team members
     * @description Get a paginated list of team members for the provided team.
     */
    get: operations["getTeamMembers"];
  };
  "/v2/user": {
    /**
     * Get the User
     * @description Retrieves information related to the currently authenticated User.
     */
    get: operations["getAuthUser"];
  };
  "/v3/events": {
    /**
     * List User Events
     * @description Retrieves a list of "events" generated by the User on Vercel. Events are generated when the User performs a particular action, such as logging in, creating a deployment, and joining a Team (just to name a few). When the `teamId` parameter is supplied, then the events that are returned will be in relation to the Team that was specified.
     */
    get: operations["listUserEvents"];
  };
  "/v3/secrets": {
    /**
     * List secrets
     * @description Retrieves the active Vercel secrets for the authenticated user. By default it returns 20 secrets. The rest can be retrieved using the pagination options. The body will contain an entry for each secret.
     */
    get: operations["getSecrets"];
  };
  "/v3/secrets/{idOrName}": {
    /**
     * Get a single secret
     * @description Retrieves the information for a specific secret by passing either the secret id or name in the URL.
     */
    get: operations["getSecret"];
  };
  "/v3/user/tokens": {
    /**
     * Create an Auth Token
     * @description Creates and returns a new authentication token for the currently authenticated User. The `bearerToken` property is only provided once, in the response body, so be sure to save it on the client for use with API requests.
     */
    post: operations["createAuthToken"];
  };
  "/v3/user/tokens/{tokenId}": {
    /**
     * Delete an authentication token
     * @description Invalidate an authentication token, such that it will no longer be valid for future HTTP requests.
     */
    delete: operations["deleteAuthToken"];
  };
  "/v4/aliases": {
    /**
     * List aliases
     * @description Retrieves a list of aliases for the authenticated User or Team. When `domain` is provided, only aliases for that domain will be returned. When `projectId` is provided, it will only return the given project aliases.
     */
    get: operations["listAliases"];
  };
  "/v4/aliases/{idOrAlias}": {
    /**
     * Get an Alias
     * @description Retrieves an Alias for the given host name or alias ID.
     */
    get: operations["getAlias"];
  };
  "/v4/domains": {
    /**
     * Register or transfer-in a new Domain
     * @description This endpoint is used for registering a new domain name with Vercel for the authenticating user, and also for initiating a domain transfer request from an external Registrar to Vercel.
     */
    post: operations["createOrTransferDomain"];
  };
  "/v4/domains/buy": {
    /**
     * Purchase a domain
     * @description Allows to purchase the specified domain.
     */
    post: operations["buyDomain"];
  };
  "/v4/domains/price": {
    /**
     * Check the price for a domain
     * @description Check the price to purchase a domain and how long a single purchase period is.
     */
    get: operations["checkDomainPrice"];
  };
  "/v4/domains/status": {
    /**
     * Check a Domain Availability
     * @description Check if a domain name is available for purchase.
     */
    get: operations["checkDomainStatus"];
  };
  "/v4/domains/{domain}/records": {
    /**
     * List existing DNS records
     * @description Retrieves a list of DNS records created for a domain name. By default it returns 20 records if no limit is provided. The rest can be retrieved using the pagination options.
     */
    get: operations["getRecords"];
  };
  "/v5/domains": {
    /**
     * List all the domains
     * @description Retrieves a list of domains registered for the authenticating user. By default it returns the last 20 domains if no limit is provided.
     */
    get: operations["getDomains"];
  };
  "/v5/domains/{domain}": {
    /**
     * Get Information for a Single Domain
     * @description Get information for a single domain in an account or team.
     */
    get: operations["getDomain"];
  };
  "/v5/user/tokens": {
    /**
     * List Auth Tokens
     * @description Retrieve a list of the current User's authentication tokens.
     */
    get: operations["listAuthTokens"];
  };
  "/v5/user/tokens/{tokenId}": {
    /**
     * Get Auth Token Metadata
     * @description Retrieve metadata about an authentication token belonging to the currently authenticated User.
     */
    get: operations["getAuthToken"];
  };
  "/v6/deployments": {
    /**
     * List deployments
     * @description List deployments under the account corresponding to the API token. If a deployment hasn't finished uploading (is incomplete), the `url` property will have a value of `null`.
     */
    get: operations["getDeployments"];
  };
  "/v6/deployments/{id}/files": {
    /**
     * List Deployment Files
     * @description Allows to retrieve the file structure of a deployment by supplying the deployment unique identifier.
     */
    get: operations["listDeploymentFiles"];
  };
  "/v6/deployments/{id}/files/{fileId}": {
    /**
     * Get Deployment File Contents
     * @description Allows to retrieve the content of a file by supplying the file identifier and the deployment unique identifier. The response body will contain the raw content of the file.
     */
    get: operations["getDeploymentFileContents"];
  };
  "/v6/domains/{domain}": {
    /**
     * Remove a domain by name
     * @description Delete a previously registered domain name from Vercel. Deleting a domain will automatically remove any associated aliases.
     */
    delete: operations["deleteDomain"];
  };
  "/v6/domains/{domain}/config": {
    /**
     * Get a Domain's configuration
     * @description Get a Domain's configuration.
     */
    get: operations["getDomainConfig"];
  };
  "/v7/certs": {
    /**
     * Upload a cert
     * @description Upload a cert
     */
    put: operations["uploadCert"];
    /**
     * Issue a new cert
     * @description Issue a new cert
     */
    post: operations["issueCert"];
  };
  "/v7/certs/{id}": {
    /**
     * Get cert by id
     * @description Get cert by id
     */
    get: operations["getCertById"];
    /**
     * Remove cert
     * @description Remove cert
     */
    delete: operations["removeCert"];
  };
  "/v8/artifacts": {
    /**
     * Query information about an artifact
     * @description Query information about an array of artifacts.
     */
    post: operations["artifactQuery"];
  };
  "/v8/artifacts/events": {
    /**
     * Record an artifacts cache usage event
     * @description Records an artifacts cache usage event. The body of this request is an array of cache usage events. The supported event types are `HIT` and `MISS`. The source is either `LOCAL` the cache event was on the users filesystem cache or `REMOTE` if the cache event is for a remote cache. When the event is a `HIT` the request also accepts a number `duration` which is the time taken to generate the artifact in the cache.
     */
    post: operations["recordEvents"];
  };
  "/v8/artifacts/status": {
    /**
     * Get status of Remote Caching for this principal
     * @description Check the status of Remote Caching for this principal. Returns a JSON-encoded status indicating if Remote Caching is enabled, disabled, or disabled due to usage limits.
     */
    get: operations["status"];
  };
  "/v8/artifacts/{hash}": {
    /**
     * Download a cache artifact
     * @description Downloads a cache artifact indentified by its `hash` specified on the request path. The artifact is downloaded as an octet-stream. The client should verify the content-length header and response body.
     */
    get: operations["downloadArtifact"];
    /**
     * Upload a cache artifact
     * @description Uploads a cache artifact identified by the `hash` specified on the path. The cache artifact can then be downloaded with the provided `hash`.
     */
    put: operations["uploadArtifact"];
    /**
     * Check if a cache artifact exists
     * @description Check that a cache artifact with the given `hash` exists. This request returns response headers only and is equivalent to a `GET` request to this endpoint where the response contains no body.
     */
    head: operations["artifactExists"];
  };
  "/v9/projects": {
    /**
     * Retrieve a list of projects
     * @description Allows to retrieve the list of projects of the authenticated user. The list will be paginated and the provided query parameters allow filtering the returned projects.
     */
    get: operations["getProjects"];
    /**
     * Create a new project
     * @description Allows to create a new project with the provided configuration. It only requires the project `name` but more configuration can be provided to override the defaults.
     */
    post: operations["createProject"];
  };
  "/v9/projects/{idOrName}": {
    /**
     * Find a project by id or name
     * @description Get the information for a specific project by passing either the project `id` or `name` in the URL.
     */
    get: operations["getProject"];
    /**
     * Delete a Project
     * @description Delete a specific project by passing either the project `id` or `name` in the URL.
     */
    delete: operations["deleteProject"];
    /**
     * Update an existing project
     * @description Update the fields of a project using either its `name` or `id`.
     */
    patch: operations["updateProject"];
  };
  "/v9/projects/{idOrName}/domains": {
    /**
     * Retrieve project domains by project by id or name
     * @description Retrieve the domains associated with a given project by passing either the project `id` or `name` in the URL.
     */
    get: operations["getProjectDomains"];
    /**
     * Add a domain to a project
     * @description Add a domain to the project by passing its domain name and by specifying the project by either passing the project `id` or `name` in the URL. If the domain is not yet verified to be used on this project, the request will return `verified = false`, and the domain will need to be verified according to the `verification` challenge via `POST /projects/:idOrName/domains/:domain/verify`. If the domain already exists on the project, the request will fail with a `400` status code.
     */
    post: operations["addProjectDomain"];
  };
  "/v9/projects/{idOrName}/domains/{domain}": {
    /**
     * Get a project domain
     * @description Get project domain by project id/name and domain name.
     */
    get: operations["getProjectDomain"];
    /**
     * Remove a domain from a project
     * @description Remove a domain from a project by passing the domain name and by specifying the project by either passing the project `id` or `name` in the URL.
     */
    delete: operations["removeProjectDomain"];
    /**
     * Update a project domain
     * @description Update a project domain's configuration, including the name, git branch and redirect of the domain.
     */
    patch: operations["updateProjectDomain"];
  };
  "/v9/projects/{idOrName}/domains/{domain}/verify": {
    /**
     * Verify project domain
     * @description Attempts to verify a project domain with `verified = false` by checking the correctness of the project domain's `verification` challenge.
     */
    post: operations["verifyProjectDomain"];
  };
  "/v9/projects/{idOrName}/env": {
    /**
     * Retrieve the environment variables of a project by id or name
     * @description Retrieve the environment variables for a given project by passing either the project `id` or `name` in the URL.
     */
    get: operations["filterProjectEnvs"];
  };
  "/v9/projects/{idOrName}/env/{id}": {
    /**
     * Remove an environment variable
     * @description Delete a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL.
     */
    delete: operations["removeProjectEnv"];
    /**
     * Edit an environment variable
     * @description Edit a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL.
     */
    patch: operations["editProjectEnv"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /**
     * @description Enum containing the actions that can be performed against a resource. Group operations are included.
     * @enum {string}
     */
    ACLAction: "create" | "delete" | "read" | "update" | "list" | "count";
    /** @description Authentication token metadata. */
    AuthToken: {
      /** @description Timestamp (in milliseconds) of when the token was most recently used. */
      activeAt: number;
      /** @description Timestamp (in milliseconds) of when the token was created. */
      createdAt: number;
      /** @description Timestamp (in milliseconds) of when the token expires. */
      expiresAt?: number;
      /** @description The unique identifier of the token. */
      id: string;
      /** @description The human-readable name of the token. */
      name: string;
      /** @description The origin of how the token was created. */
      origin?: string;
      /** @description The access scopes granted to the token. */
      scopes?: (OneOf<[{
          createdAt: number;
          expiresAt?: number;
          /** @enum {string} */
          origin: "saml" | "github" | "gitlab" | "bitbucket" | "email" | "manual";
          /** @enum {string} */
          type: "user";
        }, {
          createdAt: number;
          expiresAt?: number;
          /** @enum {string} */
          origin: "saml" | "github" | "gitlab" | "bitbucket" | "email" | "manual";
          teamId: string;
          /** @enum {string} */
          type: "team";
        }]>)[];
      /** @description The type of the token. */
      type: string;
    };
    /** @description Data for the currently authenticated User. */
    AuthUser: {
      /** @description set of dashboard view preferences (cards or list) per scopeId */
      activeDashboardViews?: ({
          scopeId: string;
          /** @enum {string} */
          viewPreference: "cards" | "list";
        })[];
      /** @description SHA1 hash of the avatar for the User account. Can be used in conjuction with the ... endpoint to retrieve the avatar image. */
      avatar: string | null;
      /** @description An object containing billing infomation associated with the User account. */
      billing: ({
        addons?: (("custom-deployment-suffix" | "live-support")[]) | null;
        address?: {
          city?: string;
          country?: string;
          line1: string;
          line2?: string;
          postalCode?: string;
          state?: string;
        } | null;
        cancelation?: number | null;
        contract?: {
          end: number;
          start: number;
        } | null;
        controls?: ({
          analyticsSampleRateInPercent?: number | null;
          analyticsSpendLimitInDollars?: number | null;
        }) | null;
        /** @enum {string} */
        currency?: "usd" | "eur";
        email?: string | null;
        invoiceItems?: ({
          /** @description Will be used to create an invoice item. The price must be in cents: 2000 for $20. */
          analytics?: {
            createdAt?: number;
            disabledAt?: number | null;
            frequency?: {
              /** @enum {string} */
              interval: "month";
              /** @enum {number} */
              intervalCount: 1 | 3 | 2 | 6 | 12;
            };
            hidden: boolean;
            maxQuantity?: number;
            name?: string;
            price: number;
            quantity: number;
          };
          analyticsUsage?: {
            batch: number;
            disabledAt?: number | null;
            hidden: boolean;
            name?: string;
            price: number;
            threshold: number;
          };
          artifacts?: {
            batch: number;
            disabledAt?: number | null;
            hidden: boolean;
            name?: string;
            price: number;
            threshold: number;
          };
          bandwidth?: {
            batch: number;
            disabledAt?: number | null;
            hidden: boolean;
            name?: string;
            price: number;
            threshold: number;
          };
          builds?: {
            batch: number;
            disabledAt?: number | null;
            hidden: boolean;
            name?: string;
            price: number;
            threshold: number;
          };
          /** @description Will be used to create an invoice item. The price must be in cents: 2000 for $20. */
          concurrentBuilds?: {
            createdAt?: number;
            disabledAt?: number | null;
            frequency?: {
              /** @enum {string} */
              interval: "month";
              /** @enum {number} */
              intervalCount: 1 | 3 | 2 | 6 | 12;
            };
            hidden: boolean;
            maxQuantity?: number;
            name?: string;
            price: number;
            quantity: number;
          };
          /** @description Will be used to create an invoice item. The price must be in cents: 2000 for $20. */
          customCerts?: {
            createdAt?: number;
            disabledAt?: number | null;
            frequency?: {
              /** @enum {string} */
              interval: "month";
              /** @enum {number} */
              intervalCount: 1 | 3 | 2 | 6 | 12;
            };
            hidden: boolean;
            maxQuantity?: number;
            name?: string;
            price: number;
            quantity: number;
          };
          edgeFunctionExecutionUnits?: {
            batch: number;
            disabledAt?: number | null;
            hidden: boolean;
            name?: string;
            price: number;
            threshold: number;
          };
          edgeMiddlewareInvocations?: {
            batch: number;
            disabledAt?: number | null;
            hidden: boolean;
            name?: string;
            price: number;
            threshold: number;
          };
          /** @description Will be used to create an invoice item. The price must be in cents: 2000 for $20. */
          enterprise?: {
            createdAt?: number;
            disabledAt?: number | null;
            frequency?: {
              /** @enum {string} */
              interval: "month";
              /** @enum {number} */
              intervalCount: 1 | 3 | 2 | 6 | 12;
            };
            hidden: boolean;
            maxQuantity?: number;
            name?: string;
            price: number;
            quantity: number;
          };
          /** @description Will be used to create an invoice item. The price must be in cents: 2000 for $20. */
          monitoring?: {
            createdAt?: number;
            disabledAt?: number | null;
            frequency?: {
              /** @enum {string} */
              interval: "month";
              /** @enum {number} */
              intervalCount: 1 | 3 | 2 | 6 | 12;
            };
            hidden: boolean;
            maxQuantity?: number;
            name?: string;
            price: number;
            quantity: number;
          };
          monitoringMetric?: {
            batch: number;
            disabledAt?: number | null;
            hidden: boolean;
            name?: string;
            price: number;
            threshold: number;
          };
          /** @description Will be used to create an invoice item. The price must be in cents: 2000 for $20. */
          passwordProtection?: {
            createdAt?: number;
            disabledAt?: number | null;
            frequency?: {
              /** @enum {string} */
              interval: "month";
              /** @enum {number} */
              intervalCount: 1 | 3 | 2 | 6 | 12;
            };
            hidden: boolean;
            maxQuantity?: number;
            name?: string;
            price: number;
            quantity: number;
          };
          /** @description Will be used to create an invoice item. The price must be in cents: 2000 for $20. */
          previewDeploymentSuffix?: {
            createdAt?: number;
            disabledAt?: number | null;
            frequency?: {
              /** @enum {string} */
              interval: "month";
              /** @enum {number} */
              intervalCount: 1 | 3 | 2 | 6 | 12;
            };
            hidden: boolean;
            maxQuantity?: number;
            name?: string;
            price: number;
            quantity: number;
          };
          /** @description Will be used to create an invoice item. The price must be in cents: 2000 for $20. */
          pro?: {
            createdAt?: number;
            disabledAt?: number | null;
            frequency?: {
              /** @enum {string} */
              interval: "month";
              /** @enum {number} */
              intervalCount: 1 | 3 | 2 | 6 | 12;
            };
            hidden: boolean;
            maxQuantity?: number;
            name?: string;
            price: number;
            quantity: number;
          };
          /** @description Will be used to create an invoice item. The price must be in cents: 2000 for $20. */
          saml?: {
            createdAt?: number;
            disabledAt?: number | null;
            frequency?: {
              /** @enum {string} */
              interval: "month";
              /** @enum {number} */
              intervalCount: 1 | 3 | 2 | 6 | 12;
            };
            hidden: boolean;
            maxQuantity?: number;
            name?: string;
            price: number;
            quantity: number;
          };
          serverlessFunctionExecution?: {
            batch: number;
            disabledAt?: number | null;
            hidden: boolean;
            name?: string;
            price: number;
            threshold: number;
          };
          sourceImages?: {
            batch: number;
            disabledAt?: number | null;
            hidden: boolean;
            name?: string;
            price: number;
            threshold: number;
          };
          /** @description Will be used to create an invoice item. The price must be in cents: 2000 for $20. */
          ssoProtection?: {
            createdAt?: number;
            disabledAt?: number | null;
            frequency?: {
              /** @enum {string} */
              interval: "month";
              /** @enum {number} */
              intervalCount: 1 | 3 | 2 | 6 | 12;
            };
            hidden: boolean;
            maxQuantity?: number;
            name?: string;
            price: number;
            quantity: number;
          };
          /** @description Will be used to create an invoice item. The price must be in cents: 2000 for $20. */
          teamSeats?: {
            createdAt?: number;
            disabledAt?: number | null;
            frequency?: {
              /** @enum {string} */
              interval: "month";
              /** @enum {number} */
              intervalCount: 1 | 3 | 2 | 6 | 12;
            };
            hidden: boolean;
            maxQuantity?: number;
            name?: string;
            price: number;
            quantity: number;
          };
          webAnalyticsDataPoint?: {
            batch: number;
            disabledAt?: number | null;
            hidden: boolean;
            name?: string;
            price: number;
            threshold: number;
          };
        }) | null;
        invoiceSettings?: {
          footer?: string;
        };
        language?: string | null;
        name?: string | null;
        overdue?: boolean | null;
        period: {
          end: number;
          start: number;
        } | null;
        /** @enum {string} */
        plan: "hobby" | "enterprise" | "pro";
        /** @enum {string} */
        platform?: "stripe" | "stripeTestMode";
        /** @enum {string} */
        pricingExperiment?: "august-2022";
        /** @enum {string} */
        programType?: "startup" | "agency";
        purchaseOrder?: string | null;
        /** @enum {string} */
        status?: "active" | "canceled" | "trialing" | "overdue" | "expired";
        subscriptions?: (({
            discount: ({
              coupon: {
                amountOff: number | null;
                /** @enum {string} */
                duration: "forever" | "repeating" | "once";
                durationInMonths: number | null;
                id: string;
                name: string | null;
                percentageOff: number | null;
              };
              id: string;
            }) | null;
            frequency: {
              /** @enum {string} */
              interval: "month" | "day" | "week" | "year";
              intervalCount: number;
            };
            id: string;
            items: {
                amount: number;
                id: string;
                priceId: string;
                productId: string;
                quantity: number;
              }[];
            period: {
              end: number;
              start: number;
            };
            trial: {
              end: number;
              start: number;
            } | null;
          })[]) | null;
        tax?: {
          id: string;
          type: string;
        } | null;
        trial?: {
          end: number;
          start: number;
        } | null;
      }) | null;
      /** @description UNIX timestamp (in milliseconds) when the User account was created. */
      createdAt: number;
      /** @description A record of when, under a certain scopeId, a toast was dismissed */
      dismissedToasts?: {
          dismissals: {
              createdAt: number;
              scopeId: string;
            }[];
          name: string;
        }[];
      /** @description Email address associated with the User account. */
      email: string;
      /** @description Whether the user has a trial available for a paid plan subscription. */
      hasTrialAvailable: boolean;
      /** @description The User's unique identifier. */
      id: string;
      importFlowGitNamespace?: string | number;
      importFlowGitNamespaceId?: string | number;
      /** @enum {string} */
      importFlowGitProvider?: "github" | "gitlab" | "bitbucket";
      /** @description Name associated with the User account, or `null` if none has been provided. */
      name: string | null;
      preferredScopesAndGitNamespaces?: ({
          gitNamespaceId: string | number;
          scopeId: string;
        })[];
      /** @description remote caching settings */
      remoteCaching?: {
        enabled?: boolean;
      };
      /** @description An object containing infomation related to the amount of platform resources may be allocated to the User account. */
      resourceConfig: {
        awsAccountIds?: string[];
        awsAccountType?: string;
        cfZoneName?: string;
        concurrentBuilds?: number;
        /** @description To overwrite the maximum size of an Edge Config per account. Size is in kilobytes, eg 64 leads to 64kB or 64_000 bytes worth of storage */
        edgeConfigSize?: number;
        /** @description To overwrite the number of Edge Configs an account can create. */
        edgeConfigs?: number;
        nodeType?: string;
      };
      /** @description When the User account has been "soft blocked", this property will contain the date when the restriction was enacted, and the identifier for why. */
      softBlock: ({
        blockedAt: number;
        /** @enum {string} */
        reason: "FAIR_USE_LIMITS_EXCEEDED" | "ENTERPRISE_TRIAL_ENDED" | "BLOCKED_FOR_PLATFORM_ABUSE" | "UNPAID_INVOICE" | "SUBSCRIPTION_EXPIRED" | "SUBSCRIPTION_CANCELED";
      }) | null;
      /** @description Prefix that will be used in the URL of "Preview" deployments created by the User account. */
      stagingPrefix: string;
      /** @description Unique username associated with the User account. */
      username: string;
    };
    /** @description A limited form of data for the currently authenticated User, due to the authentication token missing privileges to read the full User data. */
    AuthUserLimited: {
      /** @description SHA1 hash of the avatar for the User account. Can be used in conjuction with the ... endpoint to retrieve the avatar image. */
      avatar: string | null;
      /** @description Email address associated with the User account. */
      email: string;
      /** @description The User's unique identifier. */
      id: string;
      /** @description Property indicating that this User data contains only limited information, due to the authentication token missing privileges to read the full User data. Re-login with email, GitHub, GitLab or Bitbucket in order to upgrade the authentication token with the necessary privileges. */
      limited: boolean;
      /** @description Name associated with the User account, or `null` if none has been provided. */
      name: string | null;
      /** @description Unique username associated with the User account. */
      username: string;
    };
    /** @description The EdgeConfig. */
    EdgeConfigItem: {
      createdAt: number;
      edgeConfigId: string;
      key: string;
      updatedAt: number;
      value: components["schemas"]["EdgeConfigItemValue"];
    };
    EdgeConfigItemValue: string | number | boolean | Record<string, never> | components["schemas"]["EdgeConfigItemValue"][];
    /** @description The EdgeConfig. */
    EdgeConfigToken: {
      createdAt: number;
      edgeConfigId: string;
      /** @description This is not the token itself, but rather an id to identify the token by */
      id: string;
      label: string;
      token: string;
    };
    /** @description A deployment file tree entry */
    FileTree: {
      /** @description The list of children files of the directory (only valid for the `directory` type) */
      children?: components["schemas"]["FileTree"][];
      /** @description The content-type of the file (only valid for the `file` type) */
      contentType?: string;
      /** @description The file "mode" indicating file type and permissions. */
      mode: number;
      /** @description The name of the file tree entry */
      name: string;
      /** @description Not currently used. See `file-list-to-tree.ts`. */
      symlink?: string;
      /**
       * @description String indicating the type of file tree entry.
       * @enum {string}
       */
      type: "directory" | "file" | "symlink" | "lambda" | "middleware" | "invalid";
      /** @description The unique identifier of the file (only valid for the `file` type) */
      uid?: string;
    };
    /** @description This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data. */
    Pagination: {
      /** @description Amount of items in the current page. */
      count: number;
      /** @description Timestamp that must be used to request the next page. */
      next: number | null;
      /** @description Timestamp that must be used to request the previous page. */
      prev: number | null;
    };
    /** @description Data representing a Team. */
    Team: Record<string, never>;
    /** @description A limited form of data representing a Team, due to the authentication token missing privileges to read the full Team data. */
    TeamLimited: {
      /** @description The ID of the file used as avatar for this Team. */
      avatar: string | null;
      /** @description Will remain undocumented. Remove in v3 API. */
      created: string;
      /** @description UNIX timestamp (in milliseconds) when the Team was created. */
      createdAt: number;
      /** @description The Team's unique identifier. */
      id: string;
      /** @description Property indicating that this Team data contains only limited information, due to the authentication token missing privileges to read the full Team data. Re-login with the Team's configured SAML Single Sign-On provider in order to upgrade the authentication token with the necessary privileges. */
      limited: boolean;
      membership: OneOf<[{
        accessRequestedAt?: number;
        confirmed: boolean;
        confirmedAt: number;
        created: number;
        createdAt: number;
        joinedFrom?: {
          commitId?: string;
          dsyncConnectedAt?: number;
          dsyncUserId?: string;
          gitUserId?: string | number;
          gitUserLogin?: string;
          idpUserId?: string;
          /** @enum {string} */
          origin: "import" | "saml" | "mail" | "link" | "teams" | "github" | "gitlab" | "bitbucket" | "dsync" | "feedback";
          repoId?: string;
          repoPath?: string;
          ssoConnectedAt?: number;
          ssoUserId?: string;
        };
        /** @enum {string} */
        role: "MEMBER" | "OWNER" | "VIEWER" | "DEVELOPER" | "BILLING";
        teamId?: string;
        uid: string;
      }, {
        accessRequestedAt: number;
        confirmed: boolean;
        confirmedAt?: number;
        created: number;
        createdAt: number;
        joinedFrom?: {
          commitId?: string;
          dsyncConnectedAt?: number;
          dsyncUserId?: string;
          gitUserId?: string | number;
          gitUserLogin?: string;
          idpUserId?: string;
          /** @enum {string} */
          origin: "import" | "saml" | "mail" | "link" | "teams" | "github" | "gitlab" | "bitbucket" | "dsync" | "feedback";
          repoId?: string;
          repoPath?: string;
          ssoConnectedAt?: number;
          ssoUserId?: string;
        };
        /** @enum {string} */
        role: "MEMBER" | "OWNER" | "VIEWER" | "DEVELOPER" | "BILLING";
        teamId?: string;
        uid: string;
      }]>;
      /** @description Name associated with the Team account, or `null` if none has been provided. */
      name: string | null;
      /** @description When "Single Sign-On (SAML)" is configured, this object contains information that allows the client-side to identify whether or not this Team has SAML enforced. */
      saml?: {
        /** @description From T, pick a set of properties whose keys are in the union K */
        connection?: {
          createdAt?: number | null;
          creator: string;
          domain: string;
          id: string;
          name: string;
          /** @enum {string} */
          recordType: "A" | "AAAA" | "ALIAS" | "CAA" | "CNAME" | "MX" | "SRV" | "TXT" | "NS";
          ttl?: number;
          /** @enum {string} */
          type: "record" | "record-sys";
          value: string;
        };
        /** @description From T, pick a set of properties whose keys are in the union K */
        directory?: {
          createdAt?: number | null;
          creator: string;
          domain: string;
          id: string;
          name: string;
          /** @enum {string} */
          recordType: "A" | "AAAA" | "ALIAS" | "CAA" | "CNAME" | "MX" | "SRV" | "TXT" | "NS";
          ttl?: number;
          /** @enum {string} */
          type: "record" | "record-sys";
          value: string;
        };
        /** @description When `true`, interactions with the Team **must** be done with an authentication token that has been authenticated with the Team's SAML Single Sign-On connector. */
        enforced: boolean;
      };
      /** @description The Team's slug, which is unique across the Vercel platform. */
      slug: string;
    };
    /** @description Array of events generated by the User. */
    UserEvent: {
      /** @description Timestamp (in milliseconds) of when the event was generated. */
      createdAt: number;
      /** @description A list of "entities" within the event `text`. Useful for enhancing the displayed text with additional styling and links. */
      entities: ({
          /** @description The index of where the entity ends within the `text` (non-inclusive). */
          end: number;
          /** @description The index of where the entity begins within the `text` (inclusive). */
          start: number;
          /**
           * @description The type of entity.
           * @enum {string}
           */
          type: "target" | "author" | "bitbucket_login" | "bold" | "deployment_host" | "dns_record" | "git_link" | "github_login" | "gitlab_login" | "hook_name" | "integration" | "edge-config" | "link" | "project_name" | "scaling_rules" | "env_var_name" | "system";
        })[];
      /** @description The unique identifier of the Event. */
      id: string;
      /** @description The human-readable text of the Event. */
      text: string;
      /** @description Metadata for the User who generated the event. */
      user?: {
        avatar: string;
        email: string;
        slug?: string;
        uid: string;
        username: string;
      };
      /** @description The unique identifier of the User who generated the event. */
      userId: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Get Edge Configs
   * @description Returns all Edge Configs.
   */
  getEdgeConfigs: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      /** @description List of all edge configs. */
      200: {
        content: {
          "application/json": {
            createdAt?: number | null;
            creator?: string;
            domain?: string;
            id?: string;
            itemCount: number;
            name?: string;
            /** @enum {string} */
            recordType?: "A" | "AAAA" | "ALIAS" | "CAA" | "CNAME" | "MX" | "SRV" | "TXT" | "NS";
            sizeInBytes: number;
            ttl?: number;
            /** @enum {string} */
            type?: "record" | "record-sys";
            value?: string;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Create an Edge Config
   * @description Creates an Edge Config.
   */
  createEdgeConfig: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          items?: {
            [key: string]: (string | number | boolean | null | Record<string, never>) | ((string | number | boolean | null | Record<string, never>)[]);
          };
          slug: string;
        };
      };
    };
    responses: {
      201: {
        content: {
          "application/json": {
            blocking?: boolean;
            completedAt?: number;
            /** @enum {string} */
            conclusion?: "canceled" | "failed" | "neutral" | "succeeded" | "skipped" | "stale";
            createdAt?: number;
            deploymentId?: string;
            detailsUrl?: string;
            externalId?: string;
            id?: string;
            integrationId?: string;
            itemCount: number;
            name?: string;
            output?: {
              metrics?: {
                CLS: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                FCP: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                LCP: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                TBT: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                virtualExperienceScore?: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
              };
            };
            path?: string;
            rerequestable?: boolean;
            sizeInBytes: number;
            startedAt?: number;
            /** @enum {string} */
            status?: "registered" | "running" | "completed";
            updatedAt?: number;
          };
        };
      };
      /** @description One of the provided values in the request body is invalid. */
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Get an Edge Config
   * @description Returns an Edge Config.
   */
  getEdgeConfig: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        edgeConfigId: string;
      };
    };
    responses: {
      /** @description The EdgeConfig. */
      200: {
        content: {
          "application/json": {
            createdAt?: number | null;
            creator?: string;
            domain?: string;
            id?: string;
            itemCount: number;
            name?: string;
            /** @enum {string} */
            recordType?: "A" | "AAAA" | "ALIAS" | "CAA" | "CNAME" | "MX" | "SRV" | "TXT" | "NS";
            sizeInBytes: number;
            ttl?: number;
            /** @enum {string} */
            type?: "record" | "record-sys";
            value?: string;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Update an Edge Config
   * @description Updates an Edge Config.
   */
  updateEdgeConfig: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        edgeConfigId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          slug: string;
        };
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            blocking?: boolean;
            completedAt?: number;
            /** @enum {string} */
            conclusion?: "canceled" | "failed" | "neutral" | "succeeded" | "skipped" | "stale";
            createdAt?: number;
            deploymentId?: string;
            detailsUrl?: string;
            externalId?: string;
            id?: string;
            integrationId?: string;
            itemCount: number;
            name?: string;
            output?: {
              metrics?: {
                CLS: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                FCP: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                LCP: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                TBT: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                virtualExperienceScore?: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
              };
            };
            path?: string;
            rerequestable?: boolean;
            sizeInBytes: number;
            startedAt?: number;
            /** @enum {string} */
            status?: "registered" | "running" | "completed";
            updatedAt?: number;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       */
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Delete an Edge Config
   * @description Delete an Edge Config by id.
   */
  deleteEdgeConfig: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        edgeConfigId: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Get an Edge Config item
   * @description Returns a specific Edge Config Item.
   */
  getEdgeConfigItem: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        edgeConfigId: string;
        edgeConfigItemKey: string;
      };
    };
    responses: {
      /** @description The EdgeConfig. */
      200: {
        content: {
          "application/json": components["schemas"]["EdgeConfigItem"];
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Get Edge Config items
   * @description Returns all items of an Edge Config.
   */
  getEdgeConfigItems: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        edgeConfigId: string;
      };
    };
    responses: {
      /** @description The EdgeConfig. */
      200: {
        content: {
          "application/json": components["schemas"]["EdgeConfigItem"];
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Update Edge Config items in batch
   * @description Update multiple Edge Config Items in batch.
   */
  patchtEdgeConfigItems: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        edgeConfigId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          items: (OneOf<[{
              key: string;
              operation: "create" | "update" | "upsert";
              value: (string | number | boolean | null | Record<string, never>) | ((string | number | boolean | null | Record<string, never>)[]);
            }, {
              key: string;
              /** @constant */
              operation: "delete";
            }]>)[];
        };
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            status: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       */
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
      409: {
        content: never;
      };
    };
  };
  /**
   * Create an Edge Config token
   * @description Adds a token to an existing Edge Config.
   */
  createEdgeConfigToken: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        edgeConfigId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          label: string;
        };
      };
    };
    responses: {
      201: {
        content: {
          "application/json": {
            id: string;
            token: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       */
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Get Edge Config token meta data
   * @description Return meta data about an Edge Config token.
   */
  getEdgeConfigToken: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        edgeConfigId: string;
        token: string;
      };
    };
    responses: {
      /** @description The EdgeConfig. */
      200: {
        content: {
          "application/json": components["schemas"]["EdgeConfigToken"];
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Get all tokens of an Edge Config
   * @description Returns all tokens of an Edge Config.
   */
  getEdgeConfigTokens: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        edgeConfigId: string;
      };
    };
    responses: {
      /** @description The EdgeConfig. */
      200: {
        content: {
          "application/json": components["schemas"]["EdgeConfigToken"];
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Delete one or more Edge Config tokens
   * @description Deletes one or more tokens of an existing Edge Config.
   */
  deleteEdgeConfigTokens: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        edgeConfigId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          tokens: string[];
        };
      };
    };
    responses: {
      204: {
        content: never;
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       */
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Login with email
   * @description Request a new login for a user to get a token. This will respond with a verification token and send an email to confirm the request. Once confirmed you can use the verification token to get an authentication token.
   */
  emailLogin: {
    requestBody?: {
      content: {
        "application/json": {
          /** @description The user email. */
          email: string;
          /** @description The desired name for the token. It will be displayed on the user account details. */
          tokenName?: string;
        };
      };
    };
    responses: {
      /** @description The request was successful and an email was sent */
      200: {
        content: {
          "application/json": {
            /** @description The code the user is going to receive on the email. **Must** be displayed to the user so they can verify the request is the correct. */
            securityCode: string;
            /** @description The token used to verify the user accepted the login request */
            token: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * The provided email is invalid because the owner is blocked
       */
      400: {
        content: never;
      };
    };
  };
  /**
   * Verify a login request to get an authentication token
   * @description Verify the user accepted the login request and get a authentication token. The user email address and the token received after requesting the login must be added to the URL as a query string with the names `email` and `token`.
   */
  verifyToken: {
    parameters: {
      query: {
        /** @description Email to verify the login. */
        email?: string;
        /** @description The token returned when the login was requested. */
        token: string;
        /** @description The desired name for the token. It will be displayed on the user account details. */
        tokenName?: string;
        /** @description The SAML Profile ID, when connecting a SAML Profile to a Team member for the first time. */
        ssoUserId?: string;
      };
    };
    responses: {
      /** @description The verification was successful. */
      200: {
        content: {
          "application/json": {
            /** @description Email address of the authenticated user. */
            email: string;
            /** @description When completing SAML Single Sign-On authentication, this will be the ID of the Team that was authenticated for. */
            teamId?: string;
            /** @description The user authentication token that can be used to perform API requests. */
            token: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request query is invalid.
       * The provided token exists but is not yet confirmed
       */
      400: {
        content: never;
      };
      /**
       * @description You do not have permission to access this resource.
       * The verification sso token is invalid or not found
       * The verification token is invalid or not found
       */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Retrieve a list of all checks
   * @description List all of the checks created for a deployment.
   */
  getAllChecks: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The deployment to get all checks for */
        deploymentId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            checks: ({
                completedAt?: number;
                /** @enum {string} */
                conclusion?: "canceled" | "failed" | "neutral" | "succeeded" | "skipped" | "stale";
                createdAt: number;
                detailsUrl?: string;
                id: string;
                integrationId: string;
                name: string;
                output?: {
                  metrics?: {
                    CLS: {
                      previousValue?: number;
                      /** @enum {string} */
                      source: "web-vitals";
                      value: number | null;
                    };
                    FCP: {
                      previousValue?: number;
                      /** @enum {string} */
                      source: "web-vitals";
                      value: number | null;
                    };
                    LCP: {
                      previousValue?: number;
                      /** @enum {string} */
                      source: "web-vitals";
                      value: number | null;
                    };
                    TBT: {
                      previousValue?: number;
                      /** @enum {string} */
                      source: "web-vitals";
                      value: number | null;
                    };
                    virtualExperienceScore?: {
                      previousValue?: number;
                      /** @enum {string} */
                      source: "web-vitals";
                      value: number | null;
                    };
                  };
                };
                path?: string;
                rerequestable: boolean;
                startedAt?: number;
                /** @enum {string} */
                status: "registered" | "running" | "completed";
                updatedAt: number;
              })[];
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The deployment was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Creates a new Check
   * @description Creates a new check. This endpoint must be called with an OAuth2 or it will produce a 400 error.
   */
  createCheck: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The deployment to create the check for. */
        deploymentId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description Whether the check should block a deployment from succeeding */
          blocking: boolean;
          /** @description URL to display for further details */
          detailsUrl?: string;
          /** @description An identifier that can be used as an external reference */
          externalId?: string;
          /** @description The name of the check being created */
          name: string;
          /** @description Path of the page that is being checked */
          path?: string;
          /** @description Whether a user should be able to request for the check to be rerun if it fails */
          rerequestable?: boolean;
        };
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            blocking: boolean;
            completedAt?: number;
            /** @enum {string} */
            conclusion?: "canceled" | "failed" | "neutral" | "succeeded" | "skipped" | "stale";
            createdAt: number;
            deploymentId: string;
            detailsUrl?: string;
            externalId?: string;
            id: string;
            integrationId: string;
            name: string;
            output?: {
              metrics?: {
                CLS: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                FCP: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                LCP: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                TBT: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                virtualExperienceScore?: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
              };
            };
            path?: string;
            rerequestable?: boolean;
            startedAt?: number;
            /** @enum {string} */
            status: "registered" | "running" | "completed";
            updatedAt: number;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       * Cannot create check for finished deployment
       * The provided token is not from an OAuth2 Client
       */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The deployment was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get a single check
   * @description Return a detailed response for a single check.
   */
  getCheck: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The deployment to get the check for. */
        deploymentId: string;
        /** @description The check to fetch */
        checkId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            createdAt?: number | null;
            creator: string;
            domain: string;
            id: string;
            name: string;
            /** @enum {string} */
            recordType: "A" | "AAAA" | "ALIAS" | "CAA" | "CNAME" | "MX" | "SRV" | "TXT" | "NS";
            ttl?: number;
            /** @enum {string} */
            type: "record" | "record-sys";
            value: string;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /**
       * @description You do not have permission to access this resource.
       * The provided token is not from an OAuth2 Client that created the Check
       */
      403: {
        content: never;
      };
      /**
       * @description Check was not found
       * The deployment was not found
       */
      404: {
        content: never;
      };
    };
  };
  /**
   * Update a check
   * @description Update an existing check. This endpoint must be called with an OAuth2 or it will produce a 400 error.
   */
  updateCheck: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The deployment to update the check for. */
        deploymentId: string;
        /** @description The check being updated */
        checkId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description The result of the check being run
           * @enum {unknown}
           */
          conclusion?: "canceled" | "failed" | "neutral" | "succeeded" | "skipped";
          /** @description A URL a user may visit to see more information about the check */
          detailsUrl?: string;
          /** @description An identifier that can be used as an external reference */
          externalId?: string;
          /** @description The name of the check being created */
          name?: string;
          /** @description The results of the check Run */
          output?: {
            /** @description Metrics about the page */
            metrics?: {
              CLS: {
                /** @description Previous Cumulative Layout Shift value to display a delta */
                previousValue?: number;
                /** @enum {string} */
                source: "web-vitals";
                /** @description Cumulative Layout Shift value */
                value: number | null;
              };
              FCP: {
                /** @description Previous First Contentful Paint value to display a delta */
                previousValue?: number;
                /** @enum {string} */
                source: "web-vitals";
                /** @description First Contentful Paint value */
                value: number | null;
              };
              LCP: {
                /** @description Previous Largest Contentful Paint value to display a delta */
                previousValue?: number;
                /** @enum {string} */
                source: "web-vitals";
                /** @description Largest Contentful Paint value */
                value: number | null;
              };
              TBT: {
                /** @description Previous Total Blocking Time value to display a delta */
                previousValue?: number;
                /** @enum {unknown} */
                source: "web-vitals";
                /** @description Total Blocking Time value */
                value: number | null;
              };
              virtualExperienceScore?: {
                /** @description A previous Virtual Experience Score value to display a delta, between 0 and 100 */
                previousValue?: number;
                /** @enum {unknown} */
                source: "web-vitals";
                /** @description The calculated Virtual Experience Score value, between 0 and 100 */
                value: number | null;
              };
            };
          };
          /** @description Path of the page that is being checked */
          path?: string;
          /**
           * @description The current status of the check
           * @enum {unknown}
           */
          status?: "running" | "completed";
        };
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            blocking: boolean;
            completedAt?: number;
            /** @enum {string} */
            conclusion?: "canceled" | "failed" | "neutral" | "succeeded" | "skipped" | "stale";
            createdAt: number;
            deploymentId: string;
            detailsUrl?: string;
            externalId?: string;
            id: string;
            integrationId: string;
            name: string;
            output?: {
              metrics?: {
                CLS: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                FCP: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                LCP: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                TBT: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
                virtualExperienceScore?: {
                  previousValue?: number;
                  /** @enum {string} */
                  source: "web-vitals";
                  value: number | null;
                };
              };
            };
            path?: string;
            rerequestable?: boolean;
            startedAt?: number;
            /** @enum {string} */
            status: "registered" | "running" | "completed";
            updatedAt: number;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       * The provided token is not from an OAuth2 Client
       */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /**
       * @description Check was not found
       * The deployment was not found
       */
      404: {
        content: never;
      };
      /** @description The output provided is too large */
      413: {
        content: never;
      };
    };
  };
  /**
   * Rerequest a check
   * @description Rerequest a selected check that has failed.
   */
  rerequestCheck: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The deployment to rerun the check for. */
        deploymentId: string;
        /** @description The check to rerun */
        checkId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /**
       * @description The deployment was not found
       * Check was not found
       */
      404: {
        content: never;
      };
    };
  };
  /**
   * Update an existing DNS record
   * @description Updates an existing DNS record for a domain name.
   */
  updateRecord: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The id of the DNS record */
        recordId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description The MX priority value of the DNS record */
          mxPriority?: number | null;
          /** @description The name of the DNS record */
          name?: string | null;
          srv?: ({
            port: number | null;
            priority: number | null;
            target: string | null;
            weight: number | null;
          }) | null;
          /** @description The Time to live (TTL) value of the DNS record */
          ttl?: number | null;
          /**
           * @description The type of the DNS record
           * @enum {string|null}
           */
          type?: "A" | "AAAA" | "ALIAS" | "CAA" | "CNAME" | "MX" | "SRV" | "TXT" | "NS";
          /** @description The value of the DNS record */
          value?: string | null;
        };
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            createdAt?: number | null;
            creator: string;
            domain: string;
            id: string;
            name: string;
            /** @enum {string} */
            recordType: "A" | "AAAA" | "ALIAS" | "CAA" | "CNAME" | "MX" | "SRV" | "TXT" | "NS";
            ttl?: number;
            /** @enum {string} */
            type: "record" | "record-sys";
            value: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       */
      400: {
        content: never;
      };
      401: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
      409: {
        content: never;
      };
    };
  };
  /**
   * Retrieve an integration configuration
   * @description Allows to retrieve a the configuration with the provided id in case it exists. The authenticated user or team must be the owner of the config in order to access it.
   */
  getConfiguration: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description ID of the configuration to check */
        id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": OneOf<[{
            /** @description A timestamp that tells you when the configuration was installed successfully */
            completedAt?: number;
            /** @description A timestamp that tells you when the configuration was created */
            createdAt: number;
            /** @description A timestamp that tells you when the configuration was updated. */
            deletedAt?: number | null;
            /** @description A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team. */
            disabledAt?: number;
            /** @description The unique identifier of the configuration */
            id: string;
            /** @description The unique identifier of the app the configuration was created for */
            integrationId: string;
            /** @description Will be truthy in those cases where the configuration was created to authorize a client through the OAuth2 flow. */
            oauthConfiguration?: boolean;
            /** @description The user or team ID that owns the configuration */
            ownerId: string;
            /** @description When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access. */
            projects?: string[];
            removedLogDrainsAt?: number;
            removedProjectEnvsAt?: number;
            removedTokensAt?: number;
            removedWebhooksAt?: number;
            /** @description The resources that are allowed to be accessed by the configuration. */
            scopes: string[];
            scopesQueue?: ({
                confirmedAt?: number;
                note: string;
                requestedAt: number;
                scopes: {
                  added: ("read:integration-configuration" | "read-write:integration-configuration" | "read:deployment" | "read-write:deployment" | "read-write:deployment-check" | "read:project" | "read-write:project" | "read-write:project-env-vars" | "read-write:global-project-env-vars" | "read:team" | "read:user" | "read-write:log-drain" | "read:domain" | "read-write:domain" | "read-write:edge-config" | "read-write:otel-endpoint" | "read:monitoring")[];
                  upgraded: ("read:integration-configuration" | "read-write:integration-configuration" | "read:deployment" | "read-write:deployment" | "read-write:deployment-check" | "read:project" | "read-write:project" | "read-write:project-env-vars" | "read-write:global-project-env-vars" | "read:team" | "read:user" | "read-write:log-drain" | "read:domain" | "read-write:domain" | "read-write:edge-config" | "read-write:otel-endpoint" | "read:monitoring")[];
                };
              })[];
            /** @description The slug of the integration the configuration is created for. */
            slug: string;
            /**
             * @description Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
             * @enum {string}
             */
            source?: "marketplace" | "deploy-button" | "oauth" | "external";
            /** @description When the configuration was created for a team, this will show the ID of the team. */
            teamId?: string | null;
            /** @enum {string} */
            type: "integration-configuration";
            /** @description A timestamp that tells you when the configuration was updated. */
            updatedAt: number;
            /** @description The ID of the user that created the configuration. */
            userId: string;
          }, {
            canConfigureOpenTelemetry?: boolean;
            /** @description A timestamp that tells you when the configuration was installed successfully */
            completedAt?: number;
            /** @description A timestamp that tells you when the configuration was created */
            createdAt: number;
            /** @description A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team. */
            disabledAt?: number;
            /** @description The unique identifier of the configuration */
            id: string;
            /** @description The unique identifier of the app the configuration was created for */
            integrationId: string;
            /** @description Will be truthy in those cases where the configuration was created to authorize a client through the OAuth2 flow. */
            oauthConfiguration?: boolean;
            /** @description The user or team ID that owns the configuration */
            ownerId: string;
            /**
             * @description A string representing the permission for projects. Possible values are `all` or `selected`.
             * @enum {string}
             */
            projectSelection: "selected" | "all";
            /** @description When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access. */
            projects?: string[];
            /** @description The resources that are allowed to be accessed by the configuration. */
            scopes: string[];
            /** @description The slug of the integration the configuration is created for. */
            slug: string;
            /**
             * @description Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
             * @enum {string}
             */
            source?: "marketplace" | "deploy-button" | "oauth" | "external";
            /** @description When the configuration was created for a team, this will show the ID of the team. */
            teamId?: string | null;
            /** @description A timestamp that tells you when the configuration was updated. */
            updatedAt: number;
            /** @description The ID of the user that created the configuration. */
            userId: string;
          }]>;
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The configuration was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Delete an integration configuration
   * @description Allows to remove the configuration with the `id` provided in the parameters. The configuration and all of its resources will be removed. This includes Webhooks, LogDrains and Project Env variables.
   */
  deleteConfiguration: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        id: string;
      };
    };
    responses: {
      /** @description The configuration was successfully removed */
      204: {
        content: never;
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The configuration was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get configurations for the authenticated user or team
   * @description Allows to retrieve all configurations for an authenticated integration. When the `project` view is used, configurations generated for the authorization flow will be filtered out of the results.
   */
  getConfigurations: {
    parameters: {
      query: {
        view: "account" | "project";
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      /** @description The list of configurations for the authenticated user */
      200: {
        content: {
          "application/json": OneOf<[({
              /** @description A timestamp that tells you when the configuration was installed successfully */
              completedAt?: number;
              /** @description A timestamp that tells you when the configuration was created */
              createdAt: number;
              /** @description A timestamp that tells you when the configuration was updated. */
              deletedAt?: number | null;
              /** @description A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team. */
              disabledAt?: number;
              /** @description The unique identifier of the configuration */
              id: string;
              /** @description The unique identifier of the app the configuration was created for */
              integrationId: string;
              /** @description Will be truthy in those cases where the configuration was created to authorize a client through the OAuth2 flow. */
              oauthConfiguration?: boolean;
              /** @description The user or team ID that owns the configuration */
              ownerId: string;
              /** @description When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access. */
              projects?: string[];
              removedLogDrainsAt?: number;
              removedProjectEnvsAt?: number;
              removedTokensAt?: number;
              removedWebhooksAt?: number;
              /** @description The resources that are allowed to be accessed by the configuration. */
              scopes: string[];
              scopesQueue?: ({
                  confirmedAt?: number;
                  note: string;
                  requestedAt: number;
                  scopes: {
                    added: ("read:integration-configuration" | "read-write:integration-configuration" | "read:deployment" | "read-write:deployment" | "read-write:deployment-check" | "read:project" | "read-write:project" | "read-write:project-env-vars" | "read-write:global-project-env-vars" | "read:team" | "read:user" | "read-write:log-drain" | "read:domain" | "read-write:domain" | "read-write:edge-config" | "read-write:otel-endpoint" | "read:monitoring")[];
                    upgraded: ("read:integration-configuration" | "read-write:integration-configuration" | "read:deployment" | "read-write:deployment" | "read-write:deployment-check" | "read:project" | "read-write:project" | "read-write:project-env-vars" | "read-write:global-project-env-vars" | "read:team" | "read:user" | "read-write:log-drain" | "read:domain" | "read-write:domain" | "read-write:edge-config" | "read-write:otel-endpoint" | "read:monitoring")[];
                  };
                })[];
              /** @description The slug of the integration the configuration is created for. */
              slug: string;
              /**
               * @description Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
               * @enum {string}
               */
              source?: "marketplace" | "deploy-button" | "oauth" | "external";
              /** @description When the configuration was created for a team, this will show the ID of the team. */
              teamId?: string | null;
              /** @enum {string} */
              type: "integration-configuration";
              /** @description A timestamp that tells you when the configuration was updated. */
              updatedAt: number;
              /** @description The ID of the user that created the configuration. */
              userId: string;
            })[], ({
              /** @description A timestamp that tells you when the configuration was installed successfully */
              completedAt?: number;
              /** @description A timestamp that tells you when the configuration was created */
              createdAt: number;
              /** @description A timestamp that tells you when the configuration was updated. */
              deletedAt?: number | null;
              /** @description A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team. */
              disabledAt?: number;
              /** @description The unique identifier of the configuration */
              id: string;
              integration: {
                assignedBetaLabelAt?: number;
                category: string;
                flags?: string[];
                icon: string;
                isLegacy: boolean;
                name: string;
              };
              /** @description The unique identifier of the app the configuration was created for */
              integrationId: string;
              /** @description Will be truthy in those cases where the configuration was created to authorize a client through the OAuth2 flow. */
              oauthConfiguration?: boolean;
              /** @description The user or team ID that owns the configuration */
              ownerId: string;
              /** @description When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access. */
              projects?: string[];
              removedLogDrainsAt?: number;
              removedProjectEnvsAt?: number;
              removedTokensAt?: number;
              removedWebhooksAt?: number;
              /** @description The resources that are allowed to be accessed by the configuration. */
              scopes: string[];
              scopesQueue?: ({
                  confirmedAt?: number;
                  note: string;
                  requestedAt: number;
                  scopes: {
                    added: ("read:integration-configuration" | "read-write:integration-configuration" | "read:deployment" | "read-write:deployment" | "read-write:deployment-check" | "read:project" | "read-write:project" | "read-write:project-env-vars" | "read-write:global-project-env-vars" | "read:team" | "read:user" | "read-write:log-drain" | "read:domain" | "read-write:domain" | "read-write:edge-config" | "read-write:otel-endpoint" | "read:monitoring")[];
                    upgraded: ("read:integration-configuration" | "read-write:integration-configuration" | "read:deployment" | "read-write:deployment" | "read-write:deployment-check" | "read:project" | "read-write:project" | "read-write:project-env-vars" | "read-write:global-project-env-vars" | "read:team" | "read:user" | "read-write:log-drain" | "read:domain" | "read-write:domain" | "read-write:edge-config" | "read-write:otel-endpoint" | "read:monitoring")[];
                  };
                })[];
              /** @description The slug of the integration the configuration is created for. */
              slug: string;
              /**
               * @description Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
               * @enum {string}
               */
              source?: "marketplace" | "deploy-button" | "oauth" | "external";
              /** @description When the configuration was created for a team, this will show the ID of the team. */
              teamId?: string | null;
              /** @enum {string} */
              type: "integration-configuration";
              /** @description A timestamp that tells you when the configuration was updated. */
              updatedAt: number;
              /** @description The ID of the user that created the configuration. */
              userId: string;
            })[]]>;
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * List git namespaces by provider
   * @description Lists git namespaces for a supported connector. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider is not provided, it will try to obtain it from the user that authenticated the request.
   */
  gitNamespaces: {
    parameters: {
      query?: {
        provider?: "github" | "gitlab" | "bitbucket";
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": ({
              id: string | number;
              name?: string;
              ownerType: string;
              connector: string;
              slug: string;
            })[];
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Deletes the Integration log drain with the provided `id`
   * @description Deletes the Integration log drain with the provided `id`. When using an OAuth2 Token, the log drain can be deleted only if the integration owns it.
   */
  deleteIntegrationLogDrain: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description ID of the log drain to be deleted */
        id: string;
      };
    };
    responses: {
      /** @description The log drain was successfully deleted */
      204: {
        content: never;
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The log drain was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Retrieves a list of Configurable Log Drains
   * @description Retrieves a list of Configurable Log Drains. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be accessed.
   */
  getConfigurableLogDrains: {
    parameters: {
      query?: {
        projectId?: string;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": ({
              /** @description The branch to filter logs by */
              branch?: string;
              /** @description The ID of the related integration configuration */
              configurationId?: string;
              /** @description A number containing the date when the log-drain was created in in milliseconds */
              createdAt: number;
              /**
               * @description The log-drain defined delivery format
               * @enum {string}
               */
              deliveryFormat: "json" | "ndjson" | "syslog";
              /**
               * @description The environment to filter logs by
               * @enum {string}
               */
              environment?: "preview" | "production";
              /** @description Construct a type with a set of properties K of type T */
              headers?: {
                [key: string]: string;
              };
              /** @description The log-drain id */
              id: string;
              /** @description The unique ID of the team the deployment belongs to */
              ownerId: string;
              /** @description The ID of the projects the deployment is associated with */
              projectIds?: string[];
              /** @description The log-drain defined sources */
              sources?: ("static" | "lambda" | "build" | "edge" | "external")[];
              /**
               * @description The log-drain defined delivery format
               * @enum {string}
               */
              type: "json" | "ndjson" | "syslog";
              /** @description A string with the URL of the log-drain */
              url: string;
            })[];
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Creates a Configurable Log Drain
   * @description Creates a configurable log drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed)
   */
  createConfigurableLogDrain: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description The branch regexp of log drain */
          branch?: string;
          /**
           * @description The delivery log format
           * @enum {unknown}
           */
          deliveryFormat: "json" | "ndjson";
          /**
           * @description The environment of log drain
           * @enum {unknown}
           */
          environment?: "preview" | "production";
          /** @description Headers to be sent together with the request */
          headers?: {
            [key: string]: string;
          };
          projectIds?: string[];
          sources: ("static" | "lambda" | "build" | "edge" | "external")[];
          /**
           * Format: uri
           * @description The log drain url
           */
          url: string;
        };
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            /** @description The branch to filter logs by */
            branch?: string;
            /** @description The ID of the related integration configuration */
            configurationId?: string;
            /** @description A number containing the date when the log-drain was created in in milliseconds */
            createdAt: number;
            /**
             * @description The log-drain defined delivery format
             * @enum {string}
             */
            deliveryFormat: "json" | "ndjson" | "syslog";
            /**
             * @description The environment to filter logs by
             * @enum {string}
             */
            environment?: "preview" | "production";
            /** @description The key/value pairs that will be sent as headers to the log-drain */
            headers?: {
              [key: string]: string;
            };
            /** @description The log-drain id */
            id: string;
            /** @description The unique ID of the team the deployment belongs to */
            ownerId: string;
            /** @description The ID of the projects the deployment is associated with */
            projectIds?: string[];
            /** @description The secret to validate the log-drain payload */
            secret?: string;
            /** @description The log-drain defined sources */
            sources?: ("static" | "lambda" | "build" | "edge" | "external")[];
            /**
             * @description The log-drain defined delivery format
             * @enum {string}
             */
            type: "json" | "ndjson" | "syslog";
            /** @description A string with the URL of the log-drain */
            url: string;
          };
        };
      };
      /** @description One of the provided values in the request body is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Retrieves a Configurable Log Drain
   * @description Retrieves a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be accessed.
   */
  getConfigurableLogDrain: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            /** @description The branch to filter logs by */
            branch?: string;
            /** @description The ID of the related integration configuration */
            configurationId?: string;
            /** @description A number containing the date when the log-drain was created in in milliseconds */
            createdAt: number;
            /**
             * @description The log-drain defined delivery format
             * @enum {string}
             */
            deliveryFormat: "json" | "ndjson" | "syslog";
            /**
             * @description The environment to filter logs by
             * @enum {string}
             */
            environment?: "preview" | "production";
            /** @description Construct a type with a set of properties K of type T */
            headers?: {
              [key: string]: string;
            };
            /** @description The log-drain id */
            id: string;
            /** @description The unique ID of the team the deployment belongs to */
            ownerId: string;
            /** @description The ID of the projects the deployment is associated with */
            projectIds?: string[];
            /** @description The log-drain defined sources */
            sources?: ("static" | "lambda" | "build" | "edge" | "external")[];
            /**
             * @description The log-drain defined delivery format
             * @enum {string}
             */
            type: "json" | "ndjson" | "syslog";
            /** @description A string with the URL of the log-drain */
            url: string;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Deletes a Configurable Log Drain
   * @description Deletes a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be deleted.
   */
  deleteConfigurableLogDrain: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        id: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Retrieve the decrypted value of an environment variable of a project by id
   * @description Retrieve the environment variable for a given project.
   */
  getProjectEnv: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique project identifier or the project name */
        idOrName: string;
        /** @description The unique ID for the environment variable to get the decrypted value. */
        id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            configurationId?: string | null;
            createdAt?: number;
            createdBy?: string | null;
            /** @description Whether `value` is decrypted. */
            decrypted?: boolean;
            edgeConfigId?: string | null;
            edgeConfigTokenId?: string | null;
            gitBranch?: string;
            id?: string;
            key: string;
            target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
            /** @enum {string} */
            type: "secret" | "system" | "encrypted" | "plain" | "sensitive";
            updatedAt?: number;
            updatedBy?: string | null;
            value: string;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The project could not be found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Create a Team
   * @description Create a new Team under your account. You need to send a POST request with the desired Team slug, and optionally the Team name.
   */
  createTeam: {
    requestBody?: {
      content: {
        "application/json": {
          /** @description The desired name for the Team. It will be generated from the provided slug if nothing is provided */
          name?: string;
          /** @description The desired slug for the Team */
          slug: string;
        };
      };
    };
    responses: {
      /** @description The team was created successfuly */
      200: {
        content: {
          "application/json": {
            /** @description Id of the created team */
            id: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * The slug is already in use
       */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Delete a Team
   * @description Delete a team under your account. You need to send a `DELETE` request with the desired team `id`. An optional array of reasons for deletion may also be sent.
   */
  deleteTeam: {
    parameters: {
      path: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description Optional array of objects that describe the reason why the team is being deleted. */
          reasons?: {
              /** @description Description of the reason why the team is being deleted. */
              description: string;
              /** @description Idenitifier slug of the reason why the team is being deleted. */
              slug: string;
            }[];
        };
      };
    };
    responses: {
      /** @description The Team was successfuly deleted */
      200: {
        content: {
          "application/json": {
            /** @description The ID of the deleted Team */
            id: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       */
      400: {
        content: never;
      };
      402: {
        content: never;
      };
      /**
       * @description You do not have permission to access this resource.
       * The authenticated user can't access the team
       */
      403: {
        content: never;
      };
      /** @description The team was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Delete a Team invite code
   * @description Delete an active Team invite code.
   */
  deleteTeamInviteCode: {
    parameters: {
      path: {
        /** @description The Team invite code ID. */
        inviteId: string;
        /** @description Automatically added */
        teamId: string;
      };
    };
    responses: {
      /** @description Successfully deleted Team invite code. */
      200: {
        content: {
          "application/json": {
            /** @description ID of the team. */
            id: string;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /**
       * @description You do not have permission to access this resource.
       * Invite managed by directory sync
       * Not authorized to access this team.
       */
      403: {
        content: never;
      };
      /**
       * @description Team invite code not found.
       * No team found.
       */
      404: {
        content: never;
      };
    };
  };
  /**
   * Invite a user
   * @description Invite a user to join the team specified in the URL. The authenticated user needs to be an `OWNER` in order to successfully invoke this endpoint. The user can be specified with an email or an ID. If both email and ID are provided, ID will take priority.
   */
  inviteUserToTeam: {
    parameters: {
      path: {
        /** @description Automatically added */
        teamId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /**
           * Format: email
           * @description The email address of the user to invite
           */
          email?: string;
          role?: unknown;
          /** @description The id of the user to invite */
          uid?: string;
        };
      };
    };
    responses: {
      /** @description The member was successfully added to the team */
      200: {
        content: {
          "application/json": {
            /** @description The email of the invited user */
            email: string;
            /** @description The role used for the invitation */
            role: string;
            /** @description The ID of the invited user */
            uid: string;
            /** @description The username of the invited user */
            username: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       * The user is already a team member
       * The user already requested access to the team
       * Hobby teams are not allowed to add seats.
       * The team reached the maximum allowed amount of members
       */
      400: {
        content: never;
      };
      /**
       * @description You do not have permission to access this resource.
       * The authenticated user must be a team owner to perform the action
       */
      403: {
        content: never;
      };
      /** @description The team was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Join a team
   * @description Join a team with a provided invite code or team ID.
   */
  joinTeam: {
    parameters: {
      path: {
        /** @description Automatically added */
        teamId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description The invite code to join the team. */
          inviteCode?: string;
          /** @description The team ID. */
          teamId?: string;
        };
      };
    };
    responses: {
      /** @description Successfully joined a team. */
      200: {
        content: {
          "application/json": {
            /** @description The origin of how the user joined. */
            from: string;
            /** @description The name of the team the user joined. */
            name: string;
            /** @description The slug of the team the user joined. */
            slug: string;
            /** @description The ID of the team the user joined. */
            teamId: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * Reached the max. amount of team members.
       */
      400: {
        content: never;
      };
      401: {
        content: never;
      };
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description Team not found. */
      404: {
        content: never;
      };
    };
  };
  /**
   * Remove a Team Member
   * @description Remove a Team Member from the Team, or dismiss a user that requested access, or leave a team.
   */
  removeTeamMember: {
    parameters: {
      path: {
        /** @description The user ID of the member. */
        uid: string;
        /** @description Automatically added */
        teamId: string;
      };
    };
    responses: {
      /** @description Successfully removed a member of the team. */
      200: {
        content: {
          "application/json": {
            /** @description ID of the team. */
            id: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request query is invalid.
       * Cannot leave the team as the only owner.
       */
      400: {
        content: never;
      };
      /**
       * @description You do not have permission to access this resource.
       * Not authorized to update the team.
       */
      403: {
        content: never;
      };
      /**
       * @description A user with the specified ID does not exist.
       * No team found.
       */
      404: {
        content: never;
      };
    };
  };
  /**
   * Update a Team Member
   * @description Update the membership of a Team Member on the Team specified by `teamId`, such as changing the _role_ of the member, or confirming a request to join the Team for an unconfirmed member. The authenticated user must be an `OWNER` of the Team.
   */
  updateTeamMember: {
    parameters: {
      path: {
        /** @description The ID of the member. */
        uid: string;
        /** @description Automatically added */
        teamId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description Accept a user who requested access to the team.
           * @enum {boolean}
           */
          confirmed?: true;
          joinedFrom?: {
            ssoUserId?: null;
          };
          /**
           * @description The role in the team of the member.
           * @default [
           *   "MEMBER",
           *   "VIEWER"
           * ]
           */
          role?: string;
        };
      };
    };
    responses: {
      /** @description Successfully updated the membership. */
      200: {
        content: {
          "application/json": {
            /** @description ID of the team. */
            id: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       * Cannot disconnect SSO from a Team member that does not have a SSO connection.
       * Cannot confirm a member that is already confirmed.
       * Cannot confirm a member that did not request access.
       */
      400: {
        content: never;
      };
      /** @description Team members can only be updated by an owner, or by the authenticated user if they are only disconnecting their SAML connection to the Team. */
      401: {
        content: never;
      };
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /**
       * @description The provided user is not part of this team.
       * A user with the specified ID does not exist.
       * Team not found.
       */
      404: {
        content: never;
      };
    };
  };
  /**
   * Request access to a team
   * @description Request access to a team as a member. An owner has to approve the request. Only 10 users can request access to a team at the same time.
   */
  requestAccessToTeam: {
    parameters: {
      path: {
        /** @description Automatically added */
        teamId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          joinedFrom: {
            /** @description The commit sha if the origin is a git connector. */
            commitId?: string;
            /** @description The ID of the Git account of the user who requests access. */
            gitUserId?: string | number;
            /** @description The login name for the Git account of the user who requests access. */
            gitUserLogin?: string;
            /**
             * @description The origin of the request.
             * @enum {string}
             */
            origin: "import" | "teams" | "github" | "gitlab" | "bitbucket" | "feedback";
            /** @description The ID of the repository for the given Git connector. */
            repoId?: string;
            /** @description The path to the repository for the given Git connector. */
            repoPath?: string;
          };
        };
      };
    };
    responses: {
      /** @description Successfuly requested access to the team. */
      200: {
        content: {
          "application/json": {
            accessRequestedAt?: number;
            bitbucket: {
              login?: string;
            } | null;
            confirmed?: boolean;
            github: {
              login?: string;
            } | null;
            gitlab: {
              login?: string;
            } | null;
            joinedFrom?: {
              commitId?: string;
              dsyncConnectedAt?: number;
              dsyncUserId?: string;
              gitUserId?: string | number;
              gitUserLogin?: string;
              idpUserId?: string;
              /** @enum {string} */
              origin: "import" | "teams" | "github" | "gitlab" | "bitbucket" | "feedback" | "mail" | "link" | "saml" | "dsync";
              repoId?: string;
              repoPath?: string;
              ssoConnectedAt?: number;
              ssoUserId?: string;
            };
            teamName: string;
            teamSlug: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       */
      400: {
        content: never;
      };
      401: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The team was not found. */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get access request status
   * @description Check the status of a join request. It'll respond with a 404 if the request has been declined. If no `userId` path segment was provided, this endpoint will instead return the status of the authenticated user.
   */
  getTeamAccessRequest: {
    parameters: {
      path: {
        userId: string;
        /** @description Automatically added */
        teamId: string;
      };
    };
    responses: {
      /** @description Successfully */
      200: {
        content: {
          "application/json": {
            /** @description Timestamp in milliseconds when the user requested access to the team. */
            accessRequestedAt: number;
            /** @description Map of the connected Bitbucket account. */
            bitbucket: {
              login?: string;
            } | null;
            /** @description Current status of the membership. Will be `true` if confirmed, if pending it'll be `false`. */
            confirmed: boolean;
            /** @description Map of the connected GitHub account. */
            github: {
              login?: string;
            } | null;
            /** @description Map of the connected GitLab account. */
            gitlab: {
              login?: string;
            } | null;
            /** @description A map that describes the origin from where the user joined. */
            joinedFrom: {
              commitId?: string;
              dsyncConnectedAt?: number;
              dsyncUserId?: string;
              gitUserId?: string | number;
              gitUserLogin?: string;
              idpUserId?: string;
              /** @enum {string} */
              origin: "import" | "mail" | "link" | "teams" | "github" | "gitlab" | "bitbucket" | "saml" | "dsync" | "feedback";
              repoId?: string;
              repoPath?: string;
              ssoConnectedAt?: number;
              ssoUserId?: string;
            };
            /** @description The name of the team. */
            teamName: string;
            /** @description The slug of the team. */
            teamSlug: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request query is invalid.
       * User is already a confirmed member of the team and did not request access. Only visible when the authenticated user does have access to the team.
       */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /**
       * @description The provided user doesn't have a membership.
       * Team was not found.
       */
      404: {
        content: never;
      };
    };
  };
  /**
   * Delete User Account
   * @description Initiates the deletion process for the currently authenticated User, by sending a deletion confirmation email. The email contains a link that the user needs to visit in order to proceed with the deletion process.
   */
  requestDelete: {
    requestBody?: {
      content: {
        "application/json": {
          /** @description Optional array of objects that describe the reason why the User account is being deleted. */
          reasons?: {
              /** @description Description of the reason why the User account is being deleted. */
              description: string;
              /** @description Idenitifier slug of the reason why the User account is being deleted. */
              slug: string;
            }[];
        };
      };
    };
    responses: {
      /** @description Response indicating that the User deletion process has been initiated, and a confirmation email has been sent. */
      202: {
        content: {
          "application/json": {
            /** @description Email address of the User who has initiated deletion. */
            email: string;
            /** @description Unique identifier of the User who has initiated deletion. */
            id: string;
            /** @description User deletion progress status. */
            message: string;
          };
        };
      };
      /** @description One of the provided values in the request body is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Get a list of webhooks
   * @description Get a list of webhooks
   */
  getWebhooks: {
    parameters: {
      query?: {
        projectId?: string;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": OneOf<[({
              /** @description A number containing the date when the webhook was created in in milliseconds */
              createdAt: number;
              /** @description The webhooks events */
              events: ("domain.created" | "deployment.created" | "deployment.error" | "deployment.canceled" | "deployment.succeeded" | "deployment.ready" | "deployment.check-rerequested" | "integration-configuration.permission-upgraded" | "integration-configuration.removed" | "integration-configuration.scope-change-confirmed" | "project.created" | "project.removed" | "deployment-checks-completed" | "deployment-ready" | "deployment-prepared" | "deployment-error" | "deployment-check-rerequested" | "deployment-canceled" | "project-created" | "project-removed" | "domain-created" | "deployment" | "integration-configuration-permission-updated" | "integration-configuration-removed" | "integration-configuration-scope-change-confirmed")[];
              /** @description The webhook id */
              id: string;
              /** @description The unique ID of the team the webhook belongs to */
              ownerId: string;
              /** @description The ID of the projects the webhook is associated with */
              projectIds?: string[];
              projectsMetadata: (({
                  /** @enum {string|null} */
                  framework?: "blitzjs" | "nextjs" | "gatsby" | "remix" | "astro" | "hexo" | "eleventy" | "docusaurus-2" | "docusaurus" | "preact" | "solidstart" | "dojo" | "ember" | "vue" | "scully" | "ionic-angular" | "angular" | "polymer" | "svelte" | "sveltekit" | "sveltekit-1" | "ionic-react" | "create-react-app" | "gridsome" | "umijs" | "sapper" | "saber" | "stencil" | "nuxtjs" | "redwoodjs" | "hugo" | "jekyll" | "brunch" | "middleman" | "zola" | "hydrogen" | "vite" | "vitepress" | "vuepress" | "parcel" | "sanity";
                  id: string;
                  latestDeployment?: string;
                  name: string;
                })[]) | null;
              /** @description A number containing the date when the webhook was updated in in milliseconds */
              updatedAt: number;
              /** @description A string with the URL of the webhook */
              url: string;
            })[], ({
              /** @description A number containing the date when the webhook was created in in milliseconds */
              createdAt: number;
              /** @description The webhooks events */
              events: ("domain.created" | "deployment.created" | "deployment.error" | "deployment.canceled" | "deployment.succeeded" | "deployment.ready" | "deployment.check-rerequested" | "integration-configuration.permission-upgraded" | "integration-configuration.removed" | "integration-configuration.scope-change-confirmed" | "project.created" | "project.removed" | "deployment-checks-completed" | "deployment-ready" | "deployment-prepared" | "deployment-error" | "deployment-check-rerequested" | "deployment-canceled" | "project-created" | "project-removed" | "domain-created" | "deployment" | "integration-configuration-permission-updated" | "integration-configuration-removed" | "integration-configuration-scope-change-confirmed")[];
              /** @description The webhook id */
              id: string;
              /** @description The unique ID of the team the webhook belongs to */
              ownerId: string;
              /** @description The ID of the projects the webhook is associated with */
              projectIds?: string[];
              /** @description A number containing the date when the webhook was updated in in milliseconds */
              updatedAt: number;
              /** @description A string with the URL of the webhook */
              url: string;
            })[]]>;
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Creates a webhook
   * @description Creates a webhook
   */
  createWebhook: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          events: ("mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.DomainCreate" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.DeploymentCreate" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.DeploymentErro" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.DeploymentCancele" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.DeploymentSucceede" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.DeploymentRead" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.DeploymentCheckRerequeste" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.IntegrationConfigurationPermissionUpgrade" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.IntegrationConfigurationRemove" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.IntegrationConfigurationScopeChangeConfirme" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.ProjectCreate" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.ProjectRemove" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.LegacyDeploymentChecksComplete" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.LegacyDeploymentRead" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.LegacyDeploymentPrepare" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.LegacyDeploymentErro" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.LegacyDeploymentCheckRerequeste" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.LegacyDeploymentCancele" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.LegacyProjectCreate" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.LegacyProjectRemove" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.LegacyDomainCreate" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.LegacyDeploymen" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.LegacyIntegrationConfigurationPermissionUpdate" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.LegacyIntegrationConfigurationRemove" | "mport(\"/vercel/path0/utils/webhooks/webhooks/types\").WebhookName.LegacyIntegrationConfigurationScopeChangeConfirme")[];
          projectIds?: string[];
          /** Format: uri */
          url: string;
        };
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            /** @description A number containing the date when the webhook was created in in milliseconds */
            createdAt: number;
            /** @description The webhooks events */
            events: ("domain.created" | "deployment.created" | "deployment.error" | "deployment.canceled" | "deployment.succeeded" | "deployment.ready" | "deployment.check-rerequested" | "integration-configuration.permission-upgraded" | "integration-configuration.removed" | "integration-configuration.scope-change-confirmed" | "project.created" | "project.removed" | "deployment-checks-completed" | "deployment-ready" | "deployment-prepared" | "deployment-error" | "deployment-check-rerequested" | "deployment-canceled" | "project-created" | "project-removed" | "domain-created" | "deployment" | "integration-configuration-permission-updated" | "integration-configuration-removed" | "integration-configuration-scope-change-confirmed")[];
            /** @description The webhook id */
            id: string;
            /** @description The unique ID of the team the webhook belongs to */
            ownerId: string;
            /** @description The ID of the projects the webhook is associated with */
            projectIds?: string[];
            /** @description The webhook secret used to sign the payload */
            secret: string;
            /** @description A number containing the date when the webhook was updated in in milliseconds */
            updatedAt: number;
            /** @description A string with the URL of the webhook */
            url: string;
          };
        };
      };
      /** @description One of the provided values in the request body is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Get a webhook
   * @description Get a webhook
   */
  getWebhook: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            /** @description A number containing the date when the webhook was created in in milliseconds */
            createdAt: number;
            /** @description The webhooks events */
            events: ("domain.created" | "deployment.created" | "deployment.error" | "deployment.canceled" | "deployment.succeeded" | "deployment.ready" | "deployment.check-rerequested" | "integration-configuration.permission-upgraded" | "integration-configuration.removed" | "integration-configuration.scope-change-confirmed" | "project.created" | "project.removed" | "deployment-checks-completed" | "deployment-ready" | "deployment-prepared" | "deployment-error" | "deployment-check-rerequested" | "deployment-canceled" | "project-created" | "project-removed" | "domain-created" | "deployment" | "integration-configuration-permission-updated" | "integration-configuration-removed" | "integration-configuration-scope-change-confirmed")[];
            /** @description The webhook id */
            id: string;
            /** @description The unique ID of the team the webhook belongs to */
            ownerId: string;
            /** @description The ID of the projects the webhook is associated with */
            projectIds?: string[];
            /** @description A number containing the date when the webhook was updated in in milliseconds */
            updatedAt: number;
            /** @description A string with the URL of the webhook */
            url: string;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Deletes a webhook
   * @description Deletes a webhook
   */
  deleteWebhook: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        id: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Create one or more environment variables
   * @description Create one ore more environment variables for a project by passing its `key`, `value`, `type` and `target` and by specifying the project by either passing the project `id` or `name` in the URL.
   */
  createProjectEnv: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique project identifier or the project name */
        idOrName: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": OneOf<[{
          /** @description The git branch of the environment variable */
          gitBranch?: string | null;
          /** @description The name of the environment variable */
          key: string;
          /** @description The target environment of the environment variable */
          target: ("mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Productio" | "mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Previe" | "mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Developmen")[];
          /**
           * @description The type of environment variable
           * @enum {string}
           */
          type: "system" | "secret" | "encrypted" | "plain" | "sensitive";
          /** @description The value of the environment variable */
          value: string;
        }, ({
            /** @description The git branch of the environment variable */
            gitBranch?: string | null;
            /** @description The name of the environment variable */
            key: string;
            /** @description The target environment of the environment variable */
            target: ("mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Productio" | "mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Previe" | "mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Developmen")[];
            /**
             * @description The type of environment variable
             * @enum {string}
             */
            type: "system" | "secret" | "encrypted" | "plain" | "sensitive";
            /** @description The value of the environment variable */
            value: string;
          })[]]>;
      };
    };
    responses: {
      /** @description The environment variable was created successfully */
      200: {
        content: {
          "application/json": OneOf<[({
              configurationId?: string | null;
              createdAt?: number;
              createdBy?: string | null;
              /** @description Whether `value` is decrypted. */
              decrypted?: boolean;
              edgeConfigId?: string | null;
              edgeConfigTokenId?: string | null;
              gitBranch?: string;
              id?: string;
              key: string;
              target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
              /** @enum {string} */
              type: "secret" | "system" | "encrypted" | "plain" | "sensitive";
              updatedAt?: number;
              updatedBy?: string | null;
              value: string;
            })[], {
            configurationId?: string | null;
            createdAt?: number;
            createdBy?: string | null;
            /** @description Whether `value` is decrypted. */
            decrypted?: boolean;
            edgeConfigId?: string | null;
            edgeConfigTokenId?: string | null;
            gitBranch?: string;
            id?: string;
            key?: string;
            system?: boolean;
            target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
            /** @enum {string} */
            type?: "secret" | "system" | "encrypted" | "plain" | "sensitive";
            updatedAt?: number;
            updatedBy?: string | null;
            value?: string;
          }]>;
        };
      };
      201: {
        content: {
          "application/json": {
            created: OneOf<[{
              configurationId?: string | null;
              createdAt?: number;
              createdBy?: string | null;
              /** @description Whether `value` is decrypted. */
              decrypted?: boolean;
              edgeConfigId?: string | null;
              edgeConfigTokenId?: string | null;
              gitBranch?: string;
              id?: string;
              key?: string;
              system?: boolean;
              target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
              /** @enum {string} */
              type?: "secret" | "system" | "encrypted" | "plain" | "sensitive";
              updatedAt?: number;
              updatedBy?: string | null;
              value?: string;
            }, ({
                configurationId?: string | null;
                createdAt?: number;
                createdBy?: string | null;
                /** @description Whether `value` is decrypted. */
                decrypted?: boolean;
                edgeConfigId?: string | null;
                edgeConfigTokenId?: string | null;
                gitBranch?: string;
                id?: string;
                key?: string;
                system?: boolean;
                target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
                /** @enum {string} */
                type?: "secret" | "system" | "encrypted" | "plain" | "sensitive";
                updatedAt?: number;
                updatedBy?: string | null;
                value?: string;
              })[]]>;
            failed: ({
                error: {
                  action?: string;
                  code: string;
                  envVarId?: string;
                  envVarKey?: string;
                  gitBranch?: string;
                  key?: string;
                  link?: string;
                  message: string;
                  project?: string;
                  target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
                  value?: string | (("production" | "preview" | "development")[]);
                };
              })[];
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       */
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /**
       * @description You do not have permission to access this resource.
       * The environment variable cannot be created because it already exists
       * Additional permissions are required to create production environment variables
       */
      403: {
        content: never;
      };
      /** @description The project could not be found */
      404: {
        content: never;
      };
      /** @description The project is being transfered and creating an environment variable is not possible */
      409: {
        content: never;
      };
    };
  };
  /**
   * List Deployment Builds
   * @description Retrieves the list of builds given their deployment's unique identifier.
   */
  listDeploymentBuilds: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The deployment unique identifier */
        deploymentId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            builds: ({
                /** @description An object that contains the Build's configuration */
                config?: {
                  distDir?: string;
                  forceBuildIn?: string;
                  reuseWorkPathFrom?: string;
                  zeroConfig?: boolean;
                };
                copiedFrom?: string;
                /** @description The time at which the Build was created */
                createdAt?: number;
                /** @description The region where the Build was first created */
                createdIn?: string;
                /** @description The time at which the Build was deployed */
                deployedAt?: number;
                /** @description The unique identifier of the deployment */
                deploymentId: string;
                /** @description The entrypoint of the deployment */
                entrypoint: string;
                /** @description If the Build uses the `@vercel/static` Runtime, it contains a hashed string of all outputs */
                fingerprint?: string | null;
                /** @description The unique identifier of the Build */
                id: string;
                /** @description A list of outputs for the Build that can be either Serverless Functions or static files */
                output: ({
                    /** @description The SHA1 of the file */
                    digest: string;
                    /** @description Exists if the output is an edge function. */
                    edge?: ({
                      /** @description The regions where the edge function will be invoked. Only exists if the edge function as a regional edge function, see: https://vercel.com/docs/concepts/edge-network/regions#setting-edge-function-regions */
                      regions: string[] | null;
                    }) | null;
                    /** @description If the output is a Serverless Function, an object containing the name, location and memory size of the function */
                    lambda?: {
                      deployedTo: string[];
                      functionName: string;
                      layers?: string[];
                      memorySize?: number;
                      timeout?: number;
                    } | null;
                    /** @description The POSIX file permissions */
                    mode: number;
                    /** @description The absolute path of the file or Serverless Function */
                    path: string;
                    /** @description The size of the file in bytes */
                    size?: number;
                    /**
                     * @description The type of the output
                     * @enum {string}
                     */
                    type?: "lambda" | "file" | "edge";
                  })[];
                /**
                 * @description The state of the deployment depending on the process of deploying, or if it is ready or in an error state
                 * @enum {string}
                 */
                readyState: "BUILDING" | "ERROR" | "INITIALIZING" | "QUEUED" | "READY" | "CANCELED" | "UPLOADING" | "DEPLOYING" | "ARCHIVED";
                /** @description The time at which the Build state was last modified */
                readyStateAt?: number;
                /** @description The time at which the Build was scheduled to be built */
                scheduledAt?: number | null;
                /** @description The Runtime the Build used to generate the output */
                use?: string;
              })[];
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description Deployment was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Cancel a deployment
   * @description This endpoint allows you to cancel a deployment which is currently building, by supplying its `id` in the URL.
   */
  cancelDeployment: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique identifier of the deployment. */
        id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            /** @description A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation */
            alias: string[];
            /** @description A boolean that will be true when the aliases from the alias property were assigned successfully */
            aliasAssigned: boolean;
            aliasAssignedAt?: number | boolean;
            /** @description An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null` */
            aliasError?: {
              code: string;
              message: string;
            } | null;
            aliasFinal?: string | null;
            aliasWarning?: {
              action?: string;
              code: string;
              link?: string;
              message: string;
            } | null;
            automaticAliases?: string[];
            bootedAt: number;
            build: {
              /** @description The keys of the environment variables that were assigned during the build phase. */
              env: string[];
            };
            buildErrorAt?: number;
            buildingAt: number;
            builds?: {
                /** @description An object containing the deployment's metadata */
                config?: {
                  [key: string]: string;
                };
                src?: string;
                use: string;
              }[];
            canceledAt?: number;
            /** @enum {string} */
            checksConclusion?: "succeeded" | "failed" | "skipped" | "canceled";
            /** @enum {string} */
            checksState?: "registered" | "running" | "completed";
            /** @description A number containing the date when the deployment was created in milliseconds */
            createdAt: number;
            /** @description The region where the deployment was first created */
            createdIn: string;
            /** @description Information about the deployment creator */
            creator: {
              /** @description The ID of the user that created the deployment */
              uid: string;
              /** @description The username of the user that created the deployment */
              username?: string;
            };
            /** @description The keys of the environment variables that were assigned during runtime */
            env: string[];
            errorCode?: string;
            errorLink?: string;
            errorMessage?: string | null;
            errorStep?: string;
            /** @description An object used to configure your Serverless Functions */
            functions?: {
              [key: string]: {
                excludeFiles?: string;
                includeFiles?: string;
                maxDuration?: number;
                memory?: number;
                runtime?: string;
              };
            } | null;
            gitRepo?: OneOf<[{
              defaultBranch: string;
              name: string;
              namespace: string;
              /** @enum {string} */
              ownerType: "user" | "team";
              path: string;
              private: boolean;
              projectId: number;
              /** @enum {string} */
              type: "gitlab";
              url: string;
            }, {
              defaultBranch: string;
              name: string;
              org: string;
              /** @enum {string} */
              ownerType: "user" | "team";
              path: string;
              private: boolean;
              repo: string;
              repoId: number;
              repoOwnerId: string;
              /** @enum {string} */
              type: "github";
            }, {
              defaultBranch: string;
              name: string;
              owner: string;
              /** @enum {string} */
              ownerType: "user" | "team";
              path: string;
              private: boolean;
              repoUuid: string;
              slug: string;
              /** @enum {string} */
              type: "bitbucket";
              workspaceUuid: string;
            }]>;
            gitSource?: ({
              prId?: number | null;
              ref?: string | null;
              repoId: string | number;
              sha?: string;
              /** @enum {string} */
              type: "github";
            }) | ({
              org: string;
              prId?: number | null;
              ref?: string | null;
              repo: string;
              sha?: string;
              /** @enum {string} */
              type: "github";
            }) | ({
              prId?: number | null;
              projectId: string | number;
              ref?: string | null;
              sha?: string;
              /** @enum {string} */
              type: "gitlab";
            }) | ({
              prId?: number | null;
              ref?: string | null;
              repoUuid: string;
              sha?: string;
              /** @enum {string} */
              type: "bitbucket";
              workspaceUuid?: string;
            }) | ({
              owner: string;
              prId?: number | null;
              ref?: string | null;
              sha?: string;
              slug: string;
              /** @enum {string} */
              type: "bitbucket";
            }) | {
              gitUrl: string;
              ref: string;
              sha: string;
              /** @enum {string} */
              type: "custom";
            } | {
              org?: string;
              ref: string;
              repo?: string;
              repoId: number;
              sha: string;
              /** @enum {string} */
              type: "github";
            } | {
              projectId: number;
              ref: string;
              sha: string;
              /** @enum {string} */
              type: "gitlab";
            } | {
              owner?: string;
              ref: string;
              repoUuid: string;
              sha: string;
              slug?: string;
              /** @enum {string} */
              type: "bitbucket";
              workspaceUuid: string;
            };
            /** @description A string holding the unique ID of the deployment */
            id: string;
            /** @description Vercel URL to inspect the deployment. */
            inspectorUrl: string | null;
            /** @description Is the deployment currently queued waiting for a Concurrent Build Slot to be available */
            isInConcurrentBuildsQueue: boolean;
            lambdas?: ({
                createdAt?: number;
                entrypoint?: string | null;
                id: string;
                output: {
                    functionName: string;
                    path: string;
                  }[];
                /** @enum {string} */
                readyState?: "INITIALIZING" | "BUILDING" | "READY" | "ERROR";
                readyStateAt?: number;
              })[];
            /** @description An object containing the deployment's metadata */
            meta: {
              [key: string]: string;
            };
            /** @description An monorepo manager that was used for the deployment */
            monorepoManager?: string | null;
            /** @description The name of the project associated with the deployment at the time that the deployment was created */
            name: string;
            /** @description The unique ID of the user or team the deployment belongs to */
            ownerId: string;
            /**
             * @description The pricing plan the deployment was made under
             * @enum {string}
             */
            plan: "hobby" | "enterprise" | "pro" | "oss";
            /** @description Whether or not preview comments are enabled for the deployment */
            previewCommentsEnabled?: boolean;
            /** @description The ID of the project the deployment is associated with */
            projectId: string;
            /** @description A boolean representing if the deployment is public or not. By default this is `false` */
            public: boolean;
            /**
             * @description The state of the deployment depending on the process of deploying, or if it is ready or in an error state
             * @enum {string}
             */
            readyState: "INITIALIZING" | "BUILDING" | "READY" | "ERROR" | "QUEUED" | "CANCELED";
            /** @description The regions the deployment exists in */
            regions: string[];
            /** @description A list of routes objects used to rewrite paths to point towards other internal or external paths */
            routes: ((OneOf<[{
                caseSensitive?: boolean;
                check?: boolean;
                continue?: boolean;
                dest?: string;
                has?: (OneOf<[{
                    /** @enum {string} */
                    type: "host";
                    value: string;
                  }, {
                    key: string;
                    /** @enum {string} */
                    type: "header" | "cookie" | "query";
                    value?: string;
                  }]>)[];
                headers?: {
                  [key: string]: string;
                };
                important?: boolean;
                locale?: {
                  cookie?: string;
                  /** @description Construct a type with a set of properties K of type T */
                  redirect?: {
                    [key: string]: string;
                  };
                };
                methods?: string[];
                /** @description A middleware index in the `middleware` key under the build result */
                middleware?: number;
                /** @description A middleware key within the `output` key under the build result. Overrides a `middleware` definition. */
                middlewarePath?: string;
                /** @description The original middleware matchers. */
                middlewareRawSrc?: string[];
                missing?: (OneOf<[{
                    /** @enum {string} */
                    type: "host";
                    value: string;
                  }, {
                    key: string;
                    /** @enum {string} */
                    type: "header" | "cookie" | "query";
                    value?: string;
                  }]>)[];
                override?: boolean;
                src: string;
                status?: number;
              }, {
                dest?: string;
                /** @enum {string} */
                handle: "filesystem" | "hit" | "miss" | "rewrite" | "error" | "resource";
                src?: string;
                status?: number;
              }, {
                continue: boolean;
                /** @enum {number} */
                middleware: 0;
                src: string;
              }]>)[]) | null;
            /**
             * @description Where was the deployment created from
             * @enum {string}
             */
            source?: "cli" | "git" | "import" | "import/repo" | "clone/repo";
            /**
             * @description If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
             * @enum {string|null}
             */
            target?: "staging" | "production";
            /** @description The team that owns the deployment if any */
            team?: {
              /** @description The ID of the team owner */
              id: string;
              /** @description The name of the team owner */
              name: string;
              /** @description The slug of the team owner */
              slug: string;
            };
            /** @enum {string} */
            type: "LAMBDAS";
            /** @description A string with the unique URL of the deployment */
            url: string;
            /** @description An array of domains that were provided by the user when creating the Deployment. */
            userAliases?: string[];
            /**
             * @description The platform version that was used to create the deployment.
             * @enum {number}
             */
            version: 2;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Create a new deployment
   * @description Create a new deployment with all the required and intended data. If the deployment is not a git deployment, all files must be provided with the request, either referenced or inlined. Additionally, a deployment id can be specified to redeploy a previous deployment.
   */
  createDeployment: {
    parameters: {
      query?: {
        /** @description Forces a new deployment even if there is a previous similar deployment */
        forceNew?: "0" | "1";
        /** @description Allows to skip framework detection so the API would not fail to ask for confirmation */
        skipAutoDetectionConfirmation?: "0" | "1";
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description Ignored. Can be set to get completions, validations and documentation in some editors. */
          $schema?: string;
          /** @description Aliases that will get assigned when the deployment is `READY` and the target is `production`. The client needs to make a `GET` request to its API to ensure the assignment */
          alias?: string[];
          /**
           * @deprecated
           * @description An object containing another object with information to be passed to the Build Process
           */
          build?: {
            /**
             * @deprecated
             * @description An object containing the deployment's environment variable names and values to be passed to Builds. Secrets can be referenced by prefixing the value with `@`
             */
            env?: {
              [key: string]: string;
            };
          };
          /** @description The build command for this project. When `null` is used this value will be automatically detected */
          buildCommand?: string | null;
          /**
           * @deprecated
           * @description A list of build descriptions whose src references valid source files.
           */
          builds?: {
              /** @description Optionally, an object including arbitrary metadata to be passed to the Builder */
              config?: Record<string, never>;
              /** @description A glob expression or pathname. If more than one file is resolved, one build will be created per matched file. It can include `*` and `**` */
              src?: string;
              /** @description An npm module to be installed by the build process. It can include a semver compatible version (e.g.: `@org/proj@1`) */
              use: string;
            }[];
          /** @description When set to `true`, all HTML files and Serverless Functions will have their extension removed. When visiting a path that ends with the extension, a 308 response will redirect the client to the extensionless path. */
          cleanUrls?: boolean;
          /** @description An array of cron jobs that should be created for production Deployments. */
          crons?: {
              path: string;
              schedule: string;
            }[];
          /** @description An deployment id for an existing deployment to redeploy */
          deploymentId?: string;
          /** @description The dev command for this project. When `null` is used this value will be automatically detected */
          devCommand?: string | null;
          /**
           * @deprecated
           * @description An object containing the deployment's environment variable names and values. Secrets can be referenced by prefixing the value with `@`
           */
          env?: {
            [key: string]: string;
          };
          /** @description A list of objects with the files to be deployed */
          files?: (OneOf<[{
              /** @description The file content, it could be either a `base64` (useful for images, etc.) of the files or the plain content for source code */
              data: string;
              /**
               * @description The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.
               * @enum {unknown}
               */
              encoding?: "base64" | "utf-8";
              /** @description The file name including the whole path */
              file: string;
            }, {
              /** @description The file path relative to the project root */
              file: string;
              /** @description The file contents hashed with SHA1, used to check the integrity */
              sha?: string;
              /** @description The file size in bytes */
              size?: number;
            }]>)[];
          /**
           * @description The framework that is being used for this project. When `null` is used no framework is selected
           * @enum {string|null}
           */
          framework?: null | "blitzjs" | "nextjs" | "gatsby" | "remix" | "astro" | "hexo" | "eleventy" | "docusaurus-2" | "docusaurus" | "preact" | "solidstart" | "dojo" | "ember" | "vue" | "scully" | "ionic-angular" | "angular" | "polymer" | "svelte" | "sveltekit" | "sveltekit-1" | "ionic-react" | "create-react-app" | "gridsome" | "umijs" | "sapper" | "saber" | "stencil" | "nuxtjs" | "redwoodjs" | "hugo" | "jekyll" | "brunch" | "middleman" | "zola" | "hydrogen" | "vite" | "vitepress" | "vuepress" | "parcel" | "sanity";
          /** @description An object describing custom options for your Serverless Functions. Each key must be glob pattern that matches the paths of the Serverless Functions you would like to customize (like `api/*.js` or `api/test.js`). */
          functions?: {
            [key: string]: {
              /** @description A glob pattern to match files that should be excluded from your Serverless Function. If youre using a Community Runtime, the behavior might vary. */
              excludeFiles?: string;
              /** @description A glob pattern to match files that should be included in your Serverless Function. If youre using a Community Runtime, the behavior might vary. */
              includeFiles?: string;
              /** @description An integer defining how long your Serverless Function should be allowed to run on every request in seconds (between 1 and the maximum limit of your plan). */
              maxDuration?: number;
              /** @description An integer defining the memory your Serverless Function should be provided with (between 128 and 3008). */
              memory?: number;
              /** @description The npm package name of a Runtime, including its version */
              runtime?: string;
            };
          };
          git?: {
            /** @description Specifies the branches that will not trigger an auto-deployment when committing to them. Any non specified branch is `true` by default. */
            deploymentEnabled?: OneOf<[boolean, {
              [key: string]: boolean;
            }]>;
          };
          /** @description Populates initial git metadata for different git providers. */
          gitMetadata?: {
            /** @description The name of the author of the commit */
            commitAuthorName?: string;
            /** @description The commit message */
            commitMessage?: string;
            /** @description The branch on which the commit was made */
            commitRef?: string;
            /** @description The hash of the commit */
            commitSha?: string;
            /** @description Whether or not there have been modifications to the working tree since the latest commit */
            dirty?: boolean;
            /** @description The git repository's remote origin url */
            remoteUrl: string;
          };
          /** @description Defines the Git Repository source to be deployed. This property can not be used in combination with `files`. */
          gitSource?: ({
            ref: string;
            repoId: number | string;
            sha?: string;
            /** @enum {string} */
            type: "github";
          }) | {
            org: string;
            ref: string;
            repo: string;
            sha?: string;
            /** @enum {string} */
            type: "github";
          } | ({
            projectId: number | string;
            ref: string;
            sha?: string;
            /** @enum {string} */
            type: "gitlab";
          }) | {
            ref: string;
            repoUuid: string;
            sha?: string;
            /** @enum {string} */
            type: "bitbucket";
            workspaceUuid?: string;
          } | {
            owner: string;
            ref: string;
            sha?: string;
            slug: string;
            /** @enum {string} */
            type: "bitbucket";
          };
          /** @description A list of header definitions. */
          headers?: ({
              /** @description An array of requirements that are needed to match */
              has?: ({
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "host";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value: string;
                } | ({
                  /** @description The name of the element contained in the particular type */
                  key: string;
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "header" | "cookie" | "query";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value?: string;
                }))[];
              /** @description An array of key/value pairs representing each response header. */
              headers: {
                  key: string;
                  value: string;
                }[];
              /** @description An array of requirements that are needed to match */
              missing?: ({
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "host";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value: string;
                } | ({
                  /** @description The name of the element contained in the particular type */
                  key: string;
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "header" | "cookie" | "query";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value?: string;
                }))[];
              /** @description A pattern that matches each incoming pathname (excluding querystring) */
              source: string;
            })[];
          ignoreCommand?: string | null;
          /** @description The install command for this project. When `null` is used this value will be automatically detected */
          installCommand?: string | null;
          /** @description An object containing the deployment's metadata. Multiple key-value pairs can be attached to a deployment */
          meta?: {
            [key: string]: string;
          };
          /** @description The monorepo manager that is being used for this deployment. When `null` is used no monorepo manager is selected */
          monorepoManager?: string | null;
          /** @description A string with the project name used in the deployment URL */
          name: string;
          /** @description The output directory of the project. When `null` is used this value will be automatically detected */
          outputDirectory?: string | null;
          /** @description The target project identifier in which the deployment will be created. When defined, this parameter overrides name */
          project?: string;
          /** @description Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments */
          projectSettings?: {
            /** @description The build command for this project. When `null` is used this value will be automatically detected */
            buildCommand?: string | null;
            commandForIgnoringBuildStep?: string | null;
            /** @description The dev command for this project. When `null` is used this value will be automatically detected */
            devCommand?: string | null;
            /**
             * @description The framework that is being used for this project. When `null` is used no framework is selected
             * @enum {string|null}
             */
            framework?: null | "blitzjs" | "nextjs" | "gatsby" | "remix" | "astro" | "hexo" | "eleventy" | "docusaurus-2" | "docusaurus" | "preact" | "solidstart" | "dojo" | "ember" | "vue" | "scully" | "ionic-angular" | "angular" | "polymer" | "svelte" | "sveltekit" | "sveltekit-1" | "ionic-react" | "create-react-app" | "gridsome" | "umijs" | "sapper" | "saber" | "stencil" | "nuxtjs" | "redwoodjs" | "hugo" | "jekyll" | "brunch" | "middleman" | "zola" | "hydrogen" | "vite" | "vitepress" | "vuepress" | "parcel" | "sanity";
            /** @description The install command for this project. When `null` is used this value will be automatically detected */
            installCommand?: string | null;
            /** @description The output directory of the project. When `null` is used this value will be automatically detected */
            outputDirectory?: string | null;
            /** @description The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root */
            rootDirectory?: string | null;
            /** @description The region to deploy Serverless Functions in this project */
            serverlessFunctionRegion?: string | null;
            /**
             * @deprecated
             * @description Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.
             */
            skipGitConnectDuringLink?: boolean;
            /** @description Indicates if there are source files outside of the root directory, typically used for monorepos */
            sourceFilesOutsideRootDirectory?: boolean;
          };
          /** @description Whether a deployment's source and logs are available publicly */
          public?: boolean;
          /**
           * Redirects
           * @description A list of redirect definitions.
           */
          redirects?: ({
              /** @description A location destination defined as an absolute pathname or external URL. */
              destination: string;
              /** @description An array of requirements that are needed to match */
              has?: ({
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "host";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value: string;
                } | ({
                  /** @description The name of the element contained in the particular type */
                  key: string;
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "header" | "cookie" | "query";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value?: string;
                }))[];
              /** @description An array of requirements that are needed to match */
              missing?: ({
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "host";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value: string;
                } | ({
                  /** @description The name of the element contained in the particular type */
                  key: string;
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "header" | "cookie" | "query";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value?: string;
                }))[];
              /** @description A boolean to toggle between permanent and temporary redirect. When `true`, the status code is `308`. When `false` the status code is `307`. */
              permanent?: boolean;
              /** @description A pattern that matches each incoming pathname (excluding querystring). */
              source: string;
            })[];
          /** @description An array of the regions the deployment's Serverless Functions should be deployed to */
          regions?: string[];
          /** @description A list of rewrite definitions. */
          rewrites?: ({
              /** @description An absolute pathname to an existing resource or an external URL. */
              destination: string;
              /** @description An array of requirements that are needed to match */
              has?: ({
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "host";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value: string;
                } | ({
                  /** @description The name of the element contained in the particular type */
                  key: string;
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "header" | "cookie" | "query";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value?: string;
                }))[];
              /** @description An array of requirements that are needed to match */
              missing?: ({
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "host";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value: string;
                } | ({
                  /** @description The name of the element contained in the particular type */
                  key: string;
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "header" | "cookie" | "query";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value?: string;
                }))[];
              /** @description A pattern that matches each incoming pathname (excluding querystring). */
              source: string;
            })[];
          /**
           * @deprecated
           * @description A list of routes objects used to rewrite paths to point towards other internal or external paths
           */
          routes?: (({
              caseSensitive?: boolean;
              check?: boolean;
              continue?: boolean;
              dest?: string;
              /** @description An array of requirements that are needed to match */
              has?: ({
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "host";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value: string;
                } | ({
                  /** @description The name of the element contained in the particular type */
                  key: string;
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "header" | "cookie" | "query";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value?: string;
                }))[];
              headers?: {
                [key: string]: string;
              };
              important?: boolean;
              locale?: {
                cookie?: string;
                default?: string;
                path?: string;
                redirect?: {
                  [key: string]: string;
                };
                value?: string;
              };
              methods?: string[];
              middleware?: number;
              middlewarePath?: string;
              middlewareRawSrc?: string[];
              /** @description An array of requirements that are needed to match */
              missing?: ({
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "host";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value: string;
                } | ({
                  /** @description The name of the element contained in the particular type */
                  key: string;
                  /**
                   * @description The type of request element to check
                   * @enum {string}
                   */
                  type: "header" | "cookie" | "query";
                  /** @description A regular expression used to match the value. Named groups can be used in the destination */
                  value?: string;
                }))[];
              override?: boolean;
              src: string;
              status?: number;
              user?: boolean;
            }) | ({
              /** @enum {string} */
              handle: "error" | "filesystem" | "hit" | "miss" | "resource" | "rewrite";
            }))[];
          /**
           * @description Either not defined, `staging`, or `production`. If `staging`, a staging alias in the format `<project>.<team>.now.sh` will be assigned. If `production`, any aliases defined in `alias` will be assigned
           * @enum {string}
           */
          target?: "staging" | "production";
          /** @description When `false`, visiting a path that ends with a forward slash will respond with a `308` status code and redirect to the path without the trailing slash. */
          trailingSlash?: boolean;
          /** @description When `true` and `deploymentId` is passed in, the sha from the previous deployment's `gitSource` is removed forcing the latest commit to be used. */
          withLatestCommit?: boolean;
        };
      };
    };
    responses: {
      /** @description The successfully created deployment */
      200: {
        content: {
          "application/json": {
            /** @description A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation */
            alias: string[];
            /** @description A boolean that will be true when the aliases from the alias property were assigned successfully */
            aliasAssigned: boolean;
            aliasAssignedAt?: number | boolean;
            /** @description An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null` */
            aliasError?: {
              code: string;
              message: string;
            } | null;
            aliasFinal?: string | null;
            aliasWarning?: {
              action?: string;
              code: string;
              link?: string;
              message: string;
            } | null;
            automaticAliases?: string[];
            bootedAt: number;
            build: {
              /** @description The keys of the environment variables that were assigned during the build phase. */
              env: string[];
            };
            buildErrorAt?: number;
            buildingAt: number;
            builds?: Record<string, never>[];
            canceledAt?: number;
            /** @enum {string} */
            checksConclusion?: "succeeded" | "failed" | "skipped" | "canceled";
            /** @enum {string} */
            checksState?: "registered" | "running" | "completed";
            /** @description A number containing the date when the deployment was created in milliseconds */
            createdAt: number;
            /** @description The region where the deployment was first created */
            createdIn: string;
            /** @description Information about the deployment creator */
            creator: {
              /** @description The ID of the user that created the deployment */
              uid: string;
              /** @description The username of the user that created the deployment */
              username?: string;
            };
            /** @description The keys of the environment variables that were assigned during runtime */
            env: string[];
            errorCode?: string;
            errorLink?: string;
            errorMessage?: string | null;
            errorStep?: string;
            /** @description An object used to configure your Serverless Functions */
            functions?: {
              [key: string]: {
                excludeFiles?: string;
                includeFiles?: string;
                maxDuration?: number;
                memory?: number;
                runtime?: string;
              };
            } | null;
            gitRepo?: OneOf<[{
              defaultBranch: string;
              name: string;
              namespace: string;
              /** @enum {string} */
              ownerType: "team" | "user";
              path: string;
              private: boolean;
              projectId: number;
              /** @enum {string} */
              type: "gitlab";
              url: string;
            }, {
              defaultBranch: string;
              name: string;
              org: string;
              /** @enum {string} */
              ownerType: "team" | "user";
              path: string;
              private: boolean;
              repo: string;
              repoId: number;
              repoOwnerId: string;
              /** @enum {string} */
              type: "github";
            }, {
              defaultBranch: string;
              name: string;
              owner: string;
              /** @enum {string} */
              ownerType: "team" | "user";
              path: string;
              private: boolean;
              repoUuid: string;
              slug: string;
              /** @enum {string} */
              type: "bitbucket";
              workspaceUuid: string;
            }]>;
            gitSource?: ({
              prId?: number | null;
              ref?: string | null;
              repoId: string | number;
              sha?: string;
              /** @enum {string} */
              type: "github";
            }) | ({
              org: string;
              prId?: number | null;
              ref?: string | null;
              repo: string;
              sha?: string;
              /** @enum {string} */
              type: "github";
            }) | ({
              prId?: number | null;
              projectId: string | number;
              ref?: string | null;
              sha?: string;
              /** @enum {string} */
              type: "gitlab";
            }) | ({
              prId?: number | null;
              ref?: string | null;
              repoUuid: string;
              sha?: string;
              /** @enum {string} */
              type: "bitbucket";
              workspaceUuid?: string;
            }) | ({
              owner: string;
              prId?: number | null;
              ref?: string | null;
              sha?: string;
              slug: string;
              /** @enum {string} */
              type: "bitbucket";
            }) | {
              gitUrl: string;
              ref: string;
              sha: string;
              /** @enum {string} */
              type: "custom";
            } | {
              org?: string;
              ref: string;
              repo?: string;
              repoId: number;
              sha: string;
              /** @enum {string} */
              type: "github";
            } | {
              projectId: number;
              ref: string;
              sha: string;
              /** @enum {string} */
              type: "gitlab";
            } | {
              owner?: string;
              ref: string;
              repoUuid: string;
              sha: string;
              slug?: string;
              /** @enum {string} */
              type: "bitbucket";
              workspaceUuid: string;
            };
            /** @description A string holding the unique ID of the deployment */
            id: string;
            /** @description Vercel URL to inspect the deployment. */
            inspectorUrl: string | null;
            /** @description Is the deployment currently queued waiting for a Concurrent Build Slot to be available */
            isInConcurrentBuildsQueue: boolean;
            lambdas?: ({
                createdAt?: number;
                entrypoint?: string | null;
                id: string;
                output: {
                    functionName: string;
                    path: string;
                  }[];
                /** @enum {string} */
                readyState?: "BUILDING" | "ERROR" | "INITIALIZING" | "READY";
                readyStateAt?: number;
              })[];
            /** @description An object containing the deployment's metadata */
            meta: {
              [key: string]: string;
            };
            /** @description An monorepo manager that was used for the deployment */
            monorepoManager?: string | null;
            /** @description The name of the project associated with the deployment at the time that the deployment was created */
            name: string;
            /** @description The unique ID of the user or team the deployment belongs to */
            ownerId: string;
            /**
             * @description The pricing plan the deployment was made under
             * @enum {string}
             */
            plan: "hobby" | "enterprise" | "pro" | "oss";
            /** @description Whether or not preview comments are enabled for the deployment */
            previewCommentsEnabled?: boolean;
            /** @description The ID of the project the deployment is associated with */
            projectId: string;
            /** @description A boolean representing if the deployment is public or not. By default this is `false` */
            public: boolean;
            /**
             * @description The state of the deployment depending on the process of deploying, or if it is ready or in an error state
             * @enum {string}
             */
            readyState: "QUEUED" | "BUILDING" | "ERROR" | "INITIALIZING" | "READY" | "CANCELED";
            /** @description The regions the deployment exists in */
            regions: string[];
            /** @description A list of routes objects used to rewrite paths to point towards other internal or external paths */
            routes: ((OneOf<[{
                caseSensitive?: boolean;
                check?: boolean;
                continue?: boolean;
                dest?: string;
                has?: (OneOf<[{
                    /** @enum {string} */
                    type: "host";
                    value: string;
                  }, {
                    key: string;
                    /** @enum {string} */
                    type: "header" | "cookie" | "query";
                    value?: string;
                  }]>)[];
                headers?: {
                  [key: string]: string;
                };
                important?: boolean;
                locale?: {
                  cookie?: string;
                  /** @description Construct a type with a set of properties K of type T */
                  redirect?: {
                    [key: string]: string;
                  };
                };
                methods?: string[];
                /** @description A middleware index in the `middleware` key under the build result */
                middleware?: number;
                /** @description A middleware key within the `output` key under the build result. Overrides a `middleware` definition. */
                middlewarePath?: string;
                /** @description The original middleware matchers. */
                middlewareRawSrc?: string[];
                missing?: (OneOf<[{
                    /** @enum {string} */
                    type: "host";
                    value: string;
                  }, {
                    key: string;
                    /** @enum {string} */
                    type: "header" | "cookie" | "query";
                    value?: string;
                  }]>)[];
                override?: boolean;
                src: string;
                status?: number;
              }, {
                dest?: string;
                /** @enum {string} */
                handle: "filesystem" | "hit" | "miss" | "rewrite" | "error" | "resource";
                src?: string;
                status?: number;
              }, {
                continue: boolean;
                /** @enum {number} */
                middleware: 0;
                src: string;
              }]>)[]) | null;
            /**
             * @description Where was the deployment created from
             * @enum {string}
             */
            source?: "cli" | "git" | "import" | "import/repo" | "clone/repo";
            /**
             * @description If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
             * @enum {string|null}
             */
            target?: "production" | "staging";
            /** @description The team that owns the deployment if any */
            team?: {
              /** @description The ID of the team owner */
              id: string;
              /** @description The name of the team owner */
              name: string;
              /** @description The slug of the team owner */
              slug: string;
            };
            /** @enum {string} */
            type: "LAMBDAS";
            /** @description A string with the unique URL of the deployment */
            url: string;
            /** @description An array of domains that were provided by the user when creating the Deployment. */
            userAliases?: string[];
            /**
             * @description The platform version that was used to create the deployment.
             * @enum {number}
             */
            version: 2;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       */
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       * Deploying to Serverless Functions to multiple regions requires a plan update
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
      /** @description The deployment project is being transferred */
      409: {
        content: never;
      };
    };
  };
  /**
   * Get a deployment by ID or URL
   * @description Retrieves information for a deployment either by supplying its ID (`id` property) or Hostname (`url` property). Additional details will be included when the authenticated user is an owner of the deployment.
   */
  getDeployment: {
    parameters: {
      query?: {
        /** @description Whether to add in gitRepo information. */
        withGitRepoInfo?: string;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique identifier or hostname of the deployment. */
        idOrUrl: string;
      };
    };
    responses: {
      /**
       * @description The deployment including only public information
       * The deployment including both public and private information
       */
      200: {
        content: {
          "application/json": OneOf<[{
            /** @description A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation */
            alias: string[];
            /** @description A boolean that will be true when the aliases from the alias property were assigned successfully */
            aliasAssigned: boolean;
            aliasAssignedAt?: number | boolean;
            /** @description An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null` */
            aliasError?: {
              code: string;
              message: string;
            } | null;
            aliasFinal?: string | null;
            aliasWarning?: {
              action?: string;
              code: string;
              link?: string;
              message: string;
            } | null;
            automaticAliases?: string[];
            bootedAt: number;
            build: {
              /** @description The keys of the environment variables that were assigned during the build phase. */
              env: string[];
            };
            buildErrorAt?: number;
            buildingAt: number;
            builds?: Record<string, never>[];
            canceledAt?: number;
            /** @enum {string} */
            checksConclusion?: "succeeded" | "failed" | "skipped" | "canceled";
            /** @enum {string} */
            checksState?: "registered" | "running" | "completed";
            /** @description A number containing the date when the deployment was created in milliseconds */
            createdAt: number;
            /** @description The region where the deployment was first created */
            createdIn: string;
            /** @description Information about the deployment creator */
            creator: {
              /** @description The ID of the user that created the deployment */
              uid: string;
              /** @description The username of the user that created the deployment */
              username?: string;
            };
            /** @description The keys of the environment variables that were assigned during runtime */
            env: string[];
            errorCode?: string;
            errorLink?: string;
            errorMessage?: string | null;
            errorStep?: string;
            /** @description An object used to configure your Serverless Functions */
            functions?: {
              [key: string]: {
                excludeFiles?: string;
                includeFiles?: string;
                maxDuration?: number;
                memory?: number;
                runtime?: string;
              };
            } | null;
            gitRepo?: OneOf<[{
              defaultBranch: string;
              name: string;
              namespace: string;
              /** @enum {string} */
              ownerType: "team" | "user";
              path: string;
              private: boolean;
              projectId: number;
              /** @enum {string} */
              type: "gitlab";
              url: string;
            }, {
              defaultBranch: string;
              name: string;
              org: string;
              /** @enum {string} */
              ownerType: "team" | "user";
              path: string;
              private: boolean;
              repo: string;
              repoId: number;
              repoOwnerId: string;
              /** @enum {string} */
              type: "github";
            }, {
              defaultBranch: string;
              name: string;
              owner: string;
              /** @enum {string} */
              ownerType: "team" | "user";
              path: string;
              private: boolean;
              repoUuid: string;
              slug: string;
              /** @enum {string} */
              type: "bitbucket";
              workspaceUuid: string;
            }]>;
            gitSource?: ({
              prId?: number | null;
              ref?: string | null;
              repoId: string | number;
              sha?: string;
              /** @enum {string} */
              type: "github";
            }) | ({
              org: string;
              prId?: number | null;
              ref?: string | null;
              repo: string;
              sha?: string;
              /** @enum {string} */
              type: "github";
            }) | ({
              prId?: number | null;
              projectId: string | number;
              ref?: string | null;
              sha?: string;
              /** @enum {string} */
              type: "gitlab";
            }) | ({
              prId?: number | null;
              ref?: string | null;
              repoUuid: string;
              sha?: string;
              /** @enum {string} */
              type: "bitbucket";
              workspaceUuid?: string;
            }) | ({
              owner: string;
              prId?: number | null;
              ref?: string | null;
              sha?: string;
              slug: string;
              /** @enum {string} */
              type: "bitbucket";
            }) | {
              gitUrl: string;
              ref: string;
              sha: string;
              /** @enum {string} */
              type: "custom";
            } | {
              org?: string;
              ref: string;
              repo?: string;
              repoId: number;
              sha: string;
              /** @enum {string} */
              type: "github";
            } | {
              projectId: number;
              ref: string;
              sha: string;
              /** @enum {string} */
              type: "gitlab";
            } | {
              owner?: string;
              ref: string;
              repoUuid: string;
              sha: string;
              slug?: string;
              /** @enum {string} */
              type: "bitbucket";
              workspaceUuid: string;
            };
            /** @description A string holding the unique ID of the deployment */
            id: string;
            /** @description Vercel URL to inspect the deployment. */
            inspectorUrl: string | null;
            /** @description Is the deployment currently queued waiting for a Concurrent Build Slot to be available */
            isInConcurrentBuildsQueue: boolean;
            lambdas?: ({
                createdAt?: number;
                entrypoint?: string | null;
                id: string;
                output: {
                    functionName: string;
                    path: string;
                  }[];
                /** @enum {string} */
                readyState?: "BUILDING" | "ERROR" | "INITIALIZING" | "READY";
                readyStateAt?: number;
              })[];
            /** @description An object containing the deployment's metadata */
            meta: {
              [key: string]: string;
            };
            /** @description An monorepo manager that was used for the deployment */
            monorepoManager?: string | null;
            /** @description The name of the project associated with the deployment at the time that the deployment was created */
            name: string;
            /** @description The unique ID of the user or team the deployment belongs to */
            ownerId: string;
            /**
             * @description The pricing plan the deployment was made under
             * @enum {string}
             */
            plan: "hobby" | "enterprise" | "pro" | "oss";
            /** @description Whether or not preview comments are enabled for the deployment */
            previewCommentsEnabled?: boolean;
            /** @description The ID of the project the deployment is associated with */
            projectId: string;
            /** @description A boolean representing if the deployment is public or not. By default this is `false` */
            public: boolean;
            /**
             * @description The state of the deployment depending on the process of deploying, or if it is ready or in an error state
             * @enum {string}
             */
            readyState: "QUEUED" | "BUILDING" | "ERROR" | "INITIALIZING" | "READY" | "CANCELED";
            /** @description The regions the deployment exists in */
            regions: string[];
            /** @description A list of routes objects used to rewrite paths to point towards other internal or external paths */
            routes: ((OneOf<[{
                caseSensitive?: boolean;
                check?: boolean;
                continue?: boolean;
                dest?: string;
                has?: (OneOf<[{
                    /** @enum {string} */
                    type: "host";
                    value: string;
                  }, {
                    key: string;
                    /** @enum {string} */
                    type: "header" | "cookie" | "query";
                    value?: string;
                  }]>)[];
                headers?: {
                  [key: string]: string;
                };
                important?: boolean;
                locale?: {
                  cookie?: string;
                  /** @description Construct a type with a set of properties K of type T */
                  redirect?: {
                    [key: string]: string;
                  };
                };
                methods?: string[];
                /** @description A middleware index in the `middleware` key under the build result */
                middleware?: number;
                /** @description A middleware key within the `output` key under the build result. Overrides a `middleware` definition. */
                middlewarePath?: string;
                /** @description The original middleware matchers. */
                middlewareRawSrc?: string[];
                missing?: (OneOf<[{
                    /** @enum {string} */
                    type: "host";
                    value: string;
                  }, {
                    key: string;
                    /** @enum {string} */
                    type: "header" | "cookie" | "query";
                    value?: string;
                  }]>)[];
                override?: boolean;
                src: string;
                status?: number;
              }, {
                dest?: string;
                /** @enum {string} */
                handle: "filesystem" | "hit" | "miss" | "rewrite" | "error" | "resource";
                src?: string;
                status?: number;
              }, {
                continue: boolean;
                /** @enum {number} */
                middleware: 0;
                src: string;
              }]>)[]) | null;
            /**
             * @description Where was the deployment created from
             * @enum {string}
             */
            source?: "cli" | "git" | "import" | "import/repo" | "clone/repo";
            /**
             * @description If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
             * @enum {string|null}
             */
            target?: "production" | "staging";
            /** @description The team that owns the deployment if any */
            team?: {
              /** @description The ID of the team owner */
              id: string;
              /** @description The name of the team owner */
              name: string;
              /** @description The slug of the team owner */
              slug: string;
            };
            /** @enum {string} */
            type: "LAMBDAS";
            /** @description A string with the unique URL of the deployment */
            url: string;
            /** @description An array of domains that were provided by the user when creating the Deployment. */
            userAliases?: string[];
            /**
             * @description The platform version that was used to create the deployment.
             * @enum {number}
             */
            version: 2;
          }, {
            /** @description A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation */
            alias: string[];
            /** @description A boolean that will be true when the aliases from the alias property were assigned successfully */
            aliasAssigned: boolean;
            /** @description An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null` */
            aliasError?: {
              code: string;
              message: string;
            } | null;
            aliasFinal?: string | null;
            aliasWarning?: {
              action?: string;
              code: string;
              link?: string;
              message: string;
            } | null;
            automaticAliases?: string[];
            bootedAt: number;
            buildErrorAt?: number;
            buildingAt: number;
            canceledAt?: number;
            /** @enum {string} */
            checksConclusion?: "succeeded" | "failed" | "skipped" | "canceled";
            /** @enum {string} */
            checksState?: "registered" | "running" | "completed";
            /** @description A number containing the date when the deployment was created in milliseconds */
            createdAt: number;
            /** @description Information about the deployment creator */
            creator: {
              /** @description The ID of the user that created the deployment */
              uid: string;
              /** @description The username of the user that created the deployment */
              username?: string;
            };
            errorCode?: string;
            errorLink?: string;
            errorMessage?: string | null;
            errorStep?: string;
            gitSource?: ({
              prId?: number | null;
              ref?: string | null;
              repoId: string | number;
              sha?: string;
              /** @enum {string} */
              type: "github";
            }) | ({
              org: string;
              prId?: number | null;
              ref?: string | null;
              repo: string;
              sha?: string;
              /** @enum {string} */
              type: "github";
            }) | ({
              prId?: number | null;
              projectId: string | number;
              ref?: string | null;
              sha?: string;
              /** @enum {string} */
              type: "gitlab";
            }) | ({
              prId?: number | null;
              ref?: string | null;
              repoUuid: string;
              sha?: string;
              /** @enum {string} */
              type: "bitbucket";
              workspaceUuid?: string;
            }) | ({
              owner: string;
              prId?: number | null;
              ref?: string | null;
              sha?: string;
              slug: string;
              /** @enum {string} */
              type: "bitbucket";
            }) | {
              gitUrl: string;
              ref: string;
              sha: string;
              /** @enum {string} */
              type: "custom";
            } | {
              org?: string;
              ref: string;
              repo?: string;
              repoId: number;
              sha: string;
              /** @enum {string} */
              type: "github";
            } | {
              projectId: number;
              ref: string;
              sha: string;
              /** @enum {string} */
              type: "gitlab";
            } | {
              owner?: string;
              ref: string;
              repoUuid: string;
              sha: string;
              slug?: string;
              /** @enum {string} */
              type: "bitbucket";
              workspaceUuid: string;
            };
            /** @description A string holding the unique ID of the deployment */
            id: string;
            lambdas?: ({
                createdAt?: number;
                entrypoint?: string | null;
                id: string;
                output: {
                    functionName: string;
                    path: string;
                  }[];
                /** @enum {string} */
                readyState?: "BUILDING" | "ERROR" | "INITIALIZING" | "READY";
                readyStateAt?: number;
              })[];
            /** @description An object containing the deployment's metadata */
            meta: {
              [key: string]: string;
            };
            /** @description The name of the project associated with the deployment at the time that the deployment was created */
            name: string;
            /** @description Whether or not preview comments are enabled for the deployment */
            previewCommentsEnabled?: boolean;
            /** @description A boolean representing if the deployment is public or not. By default this is `false` */
            public: boolean;
            /**
             * @description The state of the deployment depending on the process of deploying, or if it is ready or in an error state
             * @enum {string}
             */
            readyState: "QUEUED" | "BUILDING" | "ERROR" | "INITIALIZING" | "READY" | "CANCELED";
            /** @description The regions the deployment exists in */
            regions: string[];
            /**
             * @description Where was the deployment created from
             * @enum {string}
             */
            source?: "cli" | "git" | "import" | "import/repo" | "clone/repo";
            /**
             * @description If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
             * @enum {string|null}
             */
            target?: "production" | "staging";
            /** @description The team that owns the deployment if any */
            team?: {
              /** @description The ID of the team owner */
              id: string;
              /** @description The name of the team owner */
              name: string;
              /** @description The slug of the team owner */
              slug: string;
            };
            /** @enum {string} */
            type: "LAMBDAS";
            /** @description A string with the unique URL of the deployment */
            url: string;
            /** @description An array of domains that were provided by the user when creating the Deployment. */
            userAliases?: string[];
            /**
             * @description The platform version that was used to create the deployment.
             * @enum {number}
             */
            version: 2;
          }]>;
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The deployment was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Delete a Deployment
   * @description This API allows you to delete a deployment, either by supplying its `id` in the URL or the `url` of the deployment as a query parameter. You can obtain the ID, for example, by listing all deployments.
   */
  deleteDeployment: {
    parameters: {
      query?: {
        /** @description A Deployment or Alias URL. In case it is passed, the ID will be ignored */
        url?: string;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The ID of the deployment to be deleted */
        id: string;
      };
    };
    responses: {
      /** @description The deployment was successfully deleted */
      200: {
        content: {
          "application/json": {
            /**
             * @description A constant with the final state of the deployment.
             * @enum {string}
             */
            state: "DELETED";
            /** @description The removed deployment ID. */
            uid: string;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The deployment was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Delete an Alias
   * @description Delete an Alias with the specified ID.
   */
  deleteAlias: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The ID or alias that will be removed */
        aliasId: string;
      };
    };
    responses: {
      /** @description The alias was successfully removed */
      200: {
        content: {
          "application/json": {
            /** @enum {string} */
            status: "SUCCESS";
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The alias was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get deployment events
   * @description Get the build logs of a deployment by deployment ID and build ID. It can work as an infinite stream of logs or as a JSON endpoint depending on the input parameters.
   */
  getDeploymentEvents: {
    parameters: {
      query?: {
        /** @description Order of the returned events based on the timestamp. */
        direction?: "backward" | "forward";
        /** @description When enabled, this endpoint will return live events as they happen. */
        follow?: 0 | 1;
        /** @description Maximum number of events to return. Provide `-1` to return all available logs. */
        limit?: number;
        /** @description Deployment build ID. */
        name?: string;
        /** @description Timestamp for when build logs should be pulled from. */
        since?: number;
        /** @description Timestamp for when the build logs should be pulled up until. */
        until?: number;
        /** @description HTTP status code range to filter events by. */
        statusCode?: number | string;
        delimiter?: 0 | 1;
        builds?: 0 | 1;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique identifier or hostname of the deployment. */
        idOrUrl: string;
      };
    };
    responses: {
      /**
       * @description A stream of jsonlines where each line is a deployment log item.
       * Array of deployment logs for the provided query.
       */
      200: {
        content: {
          "application/json": ({
              created: number;
              payload: {
                date: number;
                deploymentId: string;
                id: string;
                serial: string;
                text?: string;
              };
              /** @enum {string} */
              type: "command";
            } | {
              created: number;
              payload: {
                date: number;
                deploymentId: string;
                id: string;
                info: {
                  entrypoint?: string;
                  name: string;
                  path?: string;
                  step?: string;
                  type: string;
                };
                serial: string;
              };
              /** @enum {string} */
              type: "deployment-state";
            } | {
              created: number;
              payload: {
                date: number;
                deploymentId: string;
                id: string;
                info: {
                  entrypoint?: string;
                  name: string;
                  path?: string;
                  step?: string;
                  type: string;
                };
                serial: string;
              };
              /** @enum {string} */
              type: "delimiter";
            } | {
              created: number;
              payload: {
                created: number;
                date: number;
                deploymentId: string;
                id: string;
                serial: string;
                text?: string;
              };
              /** @enum {string} */
              type: "exit";
            } | {
              created: number;
              payload: {
                date: number;
                deploymentId: string;
                id: string;
                info: {
                  entrypoint?: string;
                  name: string;
                  path?: string;
                  step?: string;
                  type: string;
                };
                requestId?: string;
                serial: string;
                text?: string;
              };
              /** @enum {string} */
              type: "middleware";
            } | ({
              created: number;
              payload: {
                date: number;
                deploymentId: string;
                id: string;
                info: {
                  entrypoint?: string;
                  name: string;
                  path?: string;
                  step?: string;
                  type: string;
                };
                requestId?: string;
                serial: string;
                statusCode?: number;
                text?: string;
              };
              /** @enum {string} */
              type: "delimiter" | "command" | "stdout" | "stderr" | "exit" | "deployment-state" | "middleware" | "middleware-invocation" | "edge-function-invocation" | "fatal";
            }))[];
          "application/stream+json": {
            created: number;
            payload: {
              date: number;
              deploymentId: string;
              id: string;
              serial: string;
              text?: string;
            };
            /** @enum {string} */
            type: "command";
          } | {
            created: number;
            payload: {
              date: number;
              deploymentId: string;
              id: string;
              info: {
                entrypoint?: string;
                name: string;
                path?: string;
                step?: string;
                type: string;
              };
              serial: string;
            };
            /** @enum {string} */
            type: "deployment-state";
          } | {
            created: number;
            payload: {
              date: number;
              deploymentId: string;
              id: string;
              info: {
                entrypoint?: string;
                name: string;
                path?: string;
                step?: string;
                type: string;
              };
              serial: string;
            };
            /** @enum {string} */
            type: "delimiter";
          } | {
            created: number;
            payload: {
              created: number;
              date: number;
              deploymentId: string;
              id: string;
              serial: string;
              text?: string;
            };
            /** @enum {string} */
            type: "exit";
          } | {
            created: number;
            payload: {
              date: number;
              deploymentId: string;
              id: string;
              info: {
                entrypoint?: string;
                name: string;
                path?: string;
                step?: string;
                type: string;
              };
              requestId?: string;
              serial: string;
              text?: string;
            };
            /** @enum {string} */
            type: "middleware";
          } | ({
            created: number;
            payload: {
              date: number;
              deploymentId: string;
              id: string;
              info: {
                entrypoint?: string;
                name: string;
                path?: string;
                step?: string;
                type: string;
              };
              requestId?: string;
              serial: string;
              statusCode?: number;
              text?: string;
            };
            /** @enum {string} */
            type: "delimiter" | "command" | "stdout" | "stderr" | "exit" | "deployment-state" | "middleware" | "middleware-invocation" | "edge-function-invocation" | "fatal";
          }) | (Record<string, never> | {
            created: number;
            payload: {
              date: number;
              deploymentId: string;
              id: string;
              serial: string;
              text?: string;
            };
            /** @enum {string} */
            type: "command";
          } | {
            created: number;
            payload: {
              date: number;
              deploymentId: string;
              id: string;
              info: {
                entrypoint?: string;
                name: string;
                path?: string;
                step?: string;
                type: string;
              };
              serial: string;
            };
            /** @enum {string} */
            type: "deployment-state";
          } | {
            created: number;
            payload: {
              date: number;
              deploymentId: string;
              id: string;
              info: {
                entrypoint?: string;
                name: string;
                path?: string;
                step?: string;
                type: string;
              };
              serial: string;
            };
            /** @enum {string} */
            type: "delimiter";
          } | {
            created: number;
            payload: {
              created: number;
              date: number;
              deploymentId: string;
              id: string;
              serial: string;
              text?: string;
            };
            /** @enum {string} */
            type: "exit";
          } | {
            created: number;
            payload: {
              date: number;
              deploymentId: string;
              id: string;
              info: {
                entrypoint?: string;
                name: string;
                path?: string;
                step?: string;
                type: string;
              };
              requestId?: string;
              serial: string;
              text?: string;
            };
            /** @enum {string} */
            type: "middleware";
          } | ({
            created: number;
            payload: {
              date: number;
              deploymentId: string;
              id: string;
              info: {
                entrypoint?: string;
                name: string;
                path?: string;
                step?: string;
                type: string;
              };
              requestId?: string;
              serial: string;
              statusCode?: number;
              text?: string;
            };
            /** @enum {string} */
            type: "delimiter" | "command" | "stdout" | "stderr" | "exit" | "deployment-state" | "middleware" | "middleware-invocation" | "edge-function-invocation" | "fatal";
          }));
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The deployment was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * List Deployment Aliases
   * @description Retrieves all Aliases for the Deployment with the given ID. The authenticated User must own the deployment.
   */
  listDeploymentAliases: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The ID of the deployment the aliases should be listed for */
        id: string;
      };
    };
    responses: {
      /** @description The list of aliases assigned to the deployment */
      200: {
        content: {
          "application/json": {
            /** @description A list of the aliases assigned to the deployment */
            aliases: ({
                /** @description The alias name, it could be a `.vercel.app` subdomain or a custom domain */
                alias: string;
                /**
                 * Format: date-time
                 * @description The date when the alias was created
                 */
                created: string;
                /** @description Construct a type with a set of properties K of type T */
                protectionBypass?: {
                  [key: string]: string;
                };
                /** @description Target destination domain for redirect when the alias is a redirect */
                redirect?: string | null;
                /** @description The unique identifier of the alias */
                uid: string;
              })[];
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The deployment was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Assign an Alias
   * @description Creates a new alias for the deployment with the given deployment ID. The authenticated user must own this deployment. If the desired alias is already assigned to another deployment, then it will be removed from the old deployment and assigned to the new one.
   */
  assignAlias: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The ID of the deployment the aliases should be listed for */
        id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description The alias we want to assign to the deployment defined in the URL */
          alias?: string;
          /** @description The redirect property will take precedence over the deployment id from the URL and consists of a hostname (like test.com) to which the alias should redirect using status code 307 */
          redirect?: string | null;
        };
      };
    };
    responses: {
      /** @description The alias was successfully assigned to the deployment */
      200: {
        content: {
          "application/json": {
            /** @description The assigned alias name */
            alias: string;
            /**
             * Format: date-time
             * @description The date when the alias was created
             */
            created: string;
            /** @description The unique identifier of the previously aliased deployment, only received when the alias was used before */
            oldDeploymentId?: string | null;
            /** @description The unique identifier of the alias */
            uid: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       * The cert for the provided alias is not ready
       * The deployment is not READY and can not be aliased
       * The supplied alias is invalid
       */
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /**
       * @description You do not have permission to access this resource.
       * If no .vercel.app alias exists then we fail (nothing to mirror)
       */
      403: {
        content: never;
      };
      /**
       * @description The domain used for the alias was not found
       * The project for the given project can not be found
       * The deployment was not found
       */
      404: {
        content: never;
      };
      /** @description The provided alias is already assigned to the given deployment */
      409: {
        content: never;
      };
    };
  };
  /**
   * Create a DNS record
   * @description Creates a DNS record for a domain.
   */
  createRecord: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The domain used to create the DNS record. */
        domain: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": ({
          /**
           * @description The type of record, it could be one of the valid DNS records.
           * @enum {string}
           */
          type: "A" | "AAAA" | "ALIAS" | "CAA" | "CNAME" | "MX" | "SRV" | "TXT" | "NS";
        }) & ({
          /** @description A subdomain name or an empty string for the root domain. */
          name: string;
          /** @description The TTL value. Must be a number between 60 and 2147483647. Default value is 60. */
          ttl?: number;
          /**
           * @description Must be of type `A`.
           * @enum {string}
           */
          type: "A";
          /**
           * Format: ipv4
           * @description The record value must be a valid IPv4 address.
           */
          value: string;
        } | {
          /** @description A subdomain name or an empty string for the root domain. */
          name: string;
          /** @description The TTL value. Must be a number between 60 and 2147483647. Default value is 60. */
          ttl?: number;
          /**
           * @description Must be of type `AAAA`.
           * @enum {string}
           */
          type: "AAAA";
          /**
           * Format: ipv6
           * @description An AAAA record pointing to an IPv6 address.
           */
          value: string;
        } | {
          /** @description A subdomain name or an empty string for the root domain. */
          name: string;
          /** @description The TTL value. Must be a number between 60 and 2147483647. Default value is 60. */
          ttl?: number;
          /**
           * @description Must be of type `ALIAS`.
           * @enum {string}
           */
          type: "ALIAS";
          /** @description An ALIAS virtual record pointing to a hostname resolved to an A record on server side. */
          value: string;
        } | {
          /** @description A subdomain name or an empty string for the root domain. */
          name: string;
          /** @description The TTL value. Must be a number between 60 and 2147483647. Default value is 60. */
          ttl?: number;
          /**
           * @description Must be of type `CAA`.
           * @enum {string}
           */
          type: "CAA";
          /** @description A CAA record to specify which Certificate Authorities (CAs) are allowed to issue certificates for the domain. */
          value: string;
        } | {
          /** @description A subdomain name or an empty string for the root domain. */
          name: string;
          /** @description The TTL value. Must be a number between 60 and 2147483647. Default value is 60. */
          ttl?: number;
          /**
           * @description Must be of type `CNAME`.
           * @enum {string}
           */
          type: "CNAME";
          /** @description A CNAME record mapping to another domain name. */
          value?: string;
        } | {
          mxPriority: number;
          /** @description A subdomain name or an empty string for the root domain. */
          name: string;
          /** @description The TTL value. Must be a number between 60 and 2147483647. Default value is 60. */
          ttl?: number;
          /**
           * @description Must be of type `MX`.
           * @enum {string}
           */
          type: "MX";
          /** @description An MX record specifying the mail server responsible for accepting messages on behalf of the domain name. */
          value: string;
        } | ({
          /** @description A subdomain name or an empty string for the root domain. */
          name: string;
          srv: {
            port: number | null;
            priority: number | null;
            target?: string;
            weight: number | null;
          };
          /** @description The TTL value. Must be a number between 60 and 2147483647. Default value is 60. */
          ttl?: number;
          /**
           * @description Must be of type `SRV`.
           * @enum {string}
           */
          type: "SRV";
        }) | {
          /** @description A subdomain name or an empty string for the root domain. */
          name: string;
          /** @description The TTL value. Must be a number between 60 and 2147483647. Default value is 60. */
          ttl?: number;
          /**
           * @description Must be of type `TXT`.
           * @enum {string}
           */
          type: "TXT";
          /** @description A TXT record containing arbitrary text. */
          value: string;
        } | {
          /** @description A subdomain name. */
          name: string;
          /** @description The TTL value. Must be a number between 60 and 2147483647. Default value is 60. */
          ttl?: number;
          /**
           * @description Must be of type `NS`.
           * @enum {string}
           */
          type: "NS";
          /** @description An NS domain value. */
          value?: string;
        });
      };
    };
    responses: {
      /** @description Successful response showing the uid of the newly created DNS record. */
      200: {
        content: {
          "application/json": OneOf<[{
            uid: string;
            updated: number;
          }, {
            /** @description The id of the newly created DNS record */
            uid: string;
          }]>;
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       */
      400: {
        content: never;
      };
      401: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
      409: {
        content: never;
      };
    };
  };
  /**
   * Delete a DNS record
   * @description Removes an existing DNS record from a domain name.
   */
  removeRecord: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        domain: string;
        recordId: string;
      };
    };
    responses: {
      /** @description Successful response by removing the specified DNS record. */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      401: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Upload Deployment Files
   * @description Before you create a deployment you need to upload the required files for that deployment. To do it, you need to first upload each file to this endpoint. Once that's completed, you can create a new deployment with the uploaded files. The file content must be placed inside the body of the request. In the case of a successful response you'll receive a status code 200 with an empty body.
   */
  uploadFile: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      header?: {
        /** @description The file size in bytes */
        "Content-Length"?: number;
        /** @description The file SHA1 used to check the integrity */
        "x-vercel-digest"?: string;
        /** @description The file SHA1 used to check the integrity */
        "x-now-digest"?: string;
        /** @description The file size as an alternative to `Content-Length` */
        "x-now-size"?: number;
      };
    };
    responses: {
      /**
       * @description File already uploaded
       * File successfully uploaded
       */
      200: {
        content: {
          "application/json": OneOf<[{
            /** @description Array of URLs where the file was updated */
            urls: string[];
          }, Record<string, never>]>;
        };
      };
      /**
       * @description One of the provided values in the headers is invalid
       * Digest is not valid
       * File size is not valid
       */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Retrieves a list of Integration log drains
   * @description Retrieves a list of all Integration log drains that are defined for the authorized account. When using an OAuth2 token, the list is limited to log drains created by the authenticated integration.
   */
  getIntegrationLogDrains: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      /** @description A list of log drains */
      200: {
        content: {
          "application/json": ({
              /** @description The branch regexp of log drain */
              branch?: string;
              /** @description The oauth2 client application id that created this log drain */
              clientId?: string;
              /** @description The client configuration this log drain was created with */
              configurationId?: string;
              /** @description A timestamp that tells you when the log drain was created */
              createdAt: number;
              /**
               * @description Whether the log drain was created by an integration or by a user
               * @enum {string}
               */
              createdFrom?: "self-served" | "integration";
              /**
               * @description The delivery log format
               * @enum {string}
               */
              deliveryFormat?: "json" | "ndjson" | "syslog";
              /**
               * @description The environment of log drain
               * @enum {string}
               */
              environment?: "production" | "preview";
              /** @description Construct a type with a set of properties K of type T */
              headers?: {
                [key: string]: string;
              };
              /** @description The unique identifier of the log drain. Always prefixed with `ld_` */
              id: string;
              /** @description The name of the log drain */
              name: string;
              /** @description The identifier of the team or user whose events will trigger the log drain */
              ownerId: string;
              projectId?: string | null;
              /** @description The identifier of the projects this log drain is associated with */
              projectIds?: string[];
              /** @description The sources from which logs are currently being delivered to this log drain. */
              sources?: ("static" | "lambda" | "build" | "edge" | "external")[];
              /**
               * @description The type of log format
               * @enum {string}
               */
              type: "json" | "ndjson" | "syslog";
              /** @description The URL to call when logs are generated */
              url: string;
            })[];
        };
      };
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Creates a new Integration Log Drain
   * @description Creates an Integration log drain. This endpoint must be called with an OAuth2 client (integration), since log drains are tied to integrations. If it is called with a different token type it will produce a 400 error.
   */
  createLogDrain: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description The branch regexp of log drain */
          branch?: string;
          /**
           * @description The delivery log format
           * @enum {unknown}
           */
          deliveryFormat?: "json" | "ndjson" | "syslog";
          /**
           * @description The environment of log drain
           * @enum {unknown}
           */
          environment?: "preview" | "production";
          /** @description Headers to be sent together with the request */
          headers?: {
            [key: string]: string;
          };
          /** @description The name of the log drain */
          name: string;
          projectIds?: string[];
          /** @description A secret to sign log drain notification headers so a consumer can verify their authenticity */
          secret?: string;
          sources?: ("static" | "lambda" | "build" | "edge" | "external")[];
          /**
           * Format: uri
           * @description The url where you will receive logs. The protocol must be `https://` or `http://` when type is `json` and `ndjson`, and `syslog+tls:` or `syslog:` when the type is `syslog`.
           */
          url: string;
        };
      };
    };
    responses: {
      /** @description The log drain was successfully created */
      200: {
        content: {
          "application/json": {
            /** @description The branch regexp of log drain */
            branch?: string;
            /** @description The oauth2 client application id that created this log drain */
            clientId?: string;
            /** @description The client configuration this log drain was created with */
            configurationId?: string;
            /** @description A timestamp that tells you when the log drain was created */
            createdAt: number;
            /**
             * @description Whether the log drain was created by an integration or by a user
             * @enum {string}
             */
            createdFrom?: "self-served" | "integration";
            /**
             * @description The delivery log format
             * @enum {string}
             */
            deliveryFormat?: "json" | "ndjson" | "syslog";
            /**
             * @description The environment of log drain
             * @enum {string}
             */
            environment?: "preview" | "production";
            /** @description Construct a type with a set of properties K of type T */
            headers?: {
              [key: string]: string;
            };
            /** @description The unique identifier of the log drain. Always prefixed with `ld_` */
            id: string;
            /** @description The name of the log drain */
            name: string;
            /** @description The identifier of the team or user whose events will trigger the log drain */
            ownerId: string;
            projectId?: string | null;
            /** @description The identifier of the projects this log drain is associated with */
            projectIds?: string[];
            /** @description The sources from which logs are currently being delivered to this log drain. */
            sources?: ("static" | "lambda" | "build" | "edge" | "external")[];
            /**
             * @description The type of log format
             * @enum {string}
             */
            type: "json" | "ndjson" | "syslog";
            /** @description The URL to call when logs are generated */
            url: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * The provided token is not from an OAuth2 Client
       */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Delete a secret
   * @description This deletes the user's secret defined in the URL.
   */
  deleteSecret: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The name or the unique identifier to which the secret belongs to. */
        idOrName: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            /** @description The date when the secret was created. */
            created: number;
            /** @description The name of the deleted secret. */
            name: string;
            /** @description The unique identifier of the deleted secret. */
            uid: string;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Create a new secret
   * @description Allows to create a new secret.
   */
  createSecret: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description Automatically added */
        name: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description Whether the secret value can be decrypted after it has been created. */
          decryptable?: boolean;
          /** @description The name of the secret (max 100 characters). */
          name: string;
          /**
           * @deprecated
           * @description Associate a secret to a project.
           */
          projectId?: string;
          /** @description The value of the new secret. */
          value: string;
        };
      };
    };
    responses: {
      /** @description Successful response showing the created secret. */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The date when the secret was created.
             */
            created: string;
            /** @description Timestamp for when the secret was created. */
            createdAt?: number;
            /** @description Indicates whether the secret value can be decrypted after it has been created. */
            decryptable?: boolean;
            /** @description The name of the secret. */
            name: string;
            /** @description The unique identifier of the project which the secret belongs to. */
            projectId?: string;
            /** @description The unique identifier of the team the secret was created for. */
            teamId?: string | null;
            /** @description The unique identifier of the secret. */
            uid: string;
            /** @description The unique identifier of the user who created the secret. */
            userId?: string;
            value: {
              data?: number[];
              /** @enum {string} */
              type?: "Buffer";
            };
          };
        };
      };
      /** @description One of the provided values in the request body is invalid. */
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Change secret name
   * @description Enables to edit the name of a user's secret. The name has to be unique to that user's secrets.
   */
  renameSecret: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The name of the secret. */
        name: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description The name of the new secret. */
          name: string;
        };
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description Enables basic storage and retrieval of dates and times.
             */
            created: string;
            name: string;
            oldName: string;
            uid: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * List all teams
   * @description Get a paginated list of all the Teams the authenticated User is a member of.
   */
  getTeams: {
    parameters: {
      query?: {
        /** @description Maximum number of Teams which may be returned. */
        limit?: number;
        /** @description Timestamp (in milliseconds) to only include Teams created since then. */
        since?: number;
        /** @description Timestamp (in milliseconds) to only include Teams created until then. */
        until?: number;
      };
    };
    responses: {
      /** @description A paginated list of teams. */
      200: {
        content: {
          "application/json": {
            pagination: components["schemas"]["Pagination"];
            teams: (components["schemas"]["Team"] | components["schemas"]["TeamLimited"])[];
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Get a Team
   * @description Get information for the Team specified by the `teamId` parameter.
   */
  getTeam: {
    parameters: {
      query?: {
        slug?: string;
      };
      path: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId: string;
      };
    };
    responses: {
      /** @description The requested team */
      200: {
        content: {
          "application/json": components["schemas"]["Team"];
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /**
       * @description You do not have permission to access this resource.
       * Not authorized to access the team.
       */
      403: {
        content: never;
      };
      /** @description Team was not found. */
      404: {
        content: never;
      };
    };
  };
  /**
   * Update a Team
   * @description Update the information of a Team specified by the `teamId` parameter. The request body should contain the information that will be updated on the Team.
   */
  patchTeam: {
    parameters: {
      path: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /**
           * Format: regex
           * @description The hash value of an uploaded image.
           */
          avatar?: string;
          /** @description A short text that describes the team. */
          description?: string;
          /** Format: regex */
          emailDomain?: string | null;
          /** @description Enable preview comments: one of on, off or default. */
          enablePreviewFeedback?: string;
          /** @description Runs a task that migrates all existing environment variables to sensitive environment variables. */
          migrateExistingEnvVariablesToSensitive?: boolean;
          /** @description The name of the team. */
          name?: string;
          /**
           * Format: hostname
           * @description Suffix that will be used for all preview deployments.
           */
          previewDeploymentSuffix?: string | null;
          /** @description Create a new invite code and replace the current one. */
          regenerateInviteCode?: boolean;
          /** @description Whether or not remote caching is enabled for the team */
          remoteCaching?: {
            /** @description Enable or disable remote caching for the team. */
            enabled?: boolean;
          };
          saml?: {
            /** @description Require that members of the team use SAML Single Sign-On. */
            enforced?: boolean;
            roles?: {
              [key: string]: "OWNER" | "MEMBER" | "VIEWER" | "DEVELOPER" | "BILLING";
            };
          };
          /** @description Sensitive environment variable policy: one of on, off or default. */
          sensitiveEnvironmentVariablePolicy?: string;
          /** @description A new slug for the team. */
          slug?: string;
        };
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Team"];
        };
      };
      /** @description One of the provided values in the request body is invalid. */
      400: {
        content: never;
      };
      402: {
        content: never;
      };
      /**
       * @description You do not have permission to access this resource.
       * Not authorized to update the team. Must be an OWNER.
       */
      403: {
        content: never;
      };
      /** @description Team was not found. */
      404: {
        content: never;
      };
    };
  };
  /**
   * List team members
   * @description Get a paginated list of team members for the provided team.
   */
  getTeamMembers: {
    parameters: {
      query?: {
        /** @description Limit how many teams should be returned */
        limit?: number;
        /** @description Timestamp in milliseconds to only include members added since then. */
        since?: number;
        /** @description Timestamp in milliseconds to only include members added until then. */
        until?: number;
        /** @description Search team members by their name, username, and email. */
        search?: string;
        /** @description Only return members with the specified team role. */
        role?: "OWNER" | "MEMBER" | "DEVELOPER" | "VIEWER";
        /** @description Exclude members who belong to the specified project. */
        excludeProject?: string;
      };
      path: {
        /** @description Automatically added */
        teamId: string;
      };
    };
    responses: {
      /** @description Paginated list of members for the team. */
      200: {
        content: {
          "application/json": {
            emailInviteCodes?: ({
                createdAt?: number;
                email?: string;
                id: string;
                isDSyncUser: boolean;
                /** @enum {string} */
                role: "MEMBER" | "OWNER" | "VIEWER" | "DEVELOPER" | "BILLING";
              })[];
            members: ({
                /** @description Timestamp in milliseconds for when this team member was accepted by an owner. */
                accessRequestedAt?: number;
                /** @description ID of the file for the Avatar of this member. */
                avatar?: string;
                /** @description Information about the Bitbucket account of this user. */
                bitbucket?: {
                  accountId?: string;
                  email?: string;
                  login?: string;
                  userId?: number;
                };
                /** @description Boolean that indicates if this member was confirmed by an owner. */
                confirmed: boolean;
                /** @description Timestamp in milliseconds when this member was added. */
                createdAt: number;
                /** @description The email of this member. */
                email: string;
                /** @description Information about the GitHub account for this user. */
                github?: {
                  accountId?: string;
                  email?: string;
                  login?: string;
                  userId?: number;
                };
                /** @description Information about the GitLab account of this user. */
                gitlab?: {
                  accountId?: string;
                  email?: string;
                  login?: string;
                  userId?: number;
                };
                /** @description Map with information about the members origin if they joined by requesting access. */
                joinedFrom?: {
                  commitId?: string;
                  dsyncConnectedAt?: number;
                  dsyncUserId?: string;
                  gitUserId?: string | number;
                  gitUserLogin?: string;
                  idpUserId?: string;
                  /** @enum {string} */
                  origin: "import" | "gitlab" | "bitbucket" | "github" | "mail" | "link" | "teams" | "saml" | "dsync" | "feedback";
                  repoId?: string;
                  repoPath?: string;
                  ssoConnectedAt?: number;
                  ssoUserId?: string;
                };
                /** @description The name of this user. */
                name?: string;
                /**
                 * @description Role of this user in the team.
                 * @enum {string}
                 */
                role: "MEMBER" | "OWNER" | "VIEWER" | "DEVELOPER" | "BILLING";
                /** @description The ID of this user. */
                uid: string;
                /** @description The unique username of this user. */
                username: string;
              })[];
            pagination: {
              /** @description Amount of items in the current page. */
              count: number;
              hasNext: boolean;
              /** @description Timestamp that must be used to request the next page. */
              next: number | null;
              /** @description Timestamp that must be used to request the previous page. */
              prev: number | null;
            };
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description No team was found. */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get the User
   * @description Retrieves information related to the currently authenticated User.
   */
  getAuthUser: {
    responses: {
      /** @description Successful response. */
      200: {
        content: {
          "application/json": {
            user: components["schemas"]["AuthUser"] | components["schemas"]["AuthUserLimited"];
          };
        };
      };
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * List User Events
   * @description Retrieves a list of "events" generated by the User on Vercel. Events are generated when the User performs a particular action, such as logging in, creating a deployment, and joining a Team (just to name a few). When the `teamId` parameter is supplied, then the events that are returned will be in relation to the Team that was specified.
   */
  listUserEvents: {
    parameters: {
      query?: {
        /** @description Maximum number of items which may be returned. */
        limit?: number;
        /** @description Timestamp to only include items created since then. */
        since?: string;
        /** @description Timestamp to only include items created until then. */
        until?: string;
        /** @description Comma-delimited list of event \"types\" to filter the results by. */
        types?: string;
        /** @description When retrieving events for a Team, the `userId` parameter may be specified to filter events generated by a specific member of the Team. */
        userId?: string;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      /** @description Successful response. */
      200: {
        content: {
          "application/json": {
            /** @description Array of events generated by the User. */
            events: components["schemas"]["UserEvent"][];
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * List secrets
   * @description Retrieves the active Vercel secrets for the authenticated user. By default it returns 20 secrets. The rest can be retrieved using the pagination options. The body will contain an entry for each secret.
   */
  getSecrets: {
    parameters: {
      query?: {
        /** @description Filter out secrets based on comma separated secret ids. */
        id?: string;
        /** @description Filter out secrets that belong to a project. */
        projectId?: string;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      /** @description Successful response retrieving a list of secrets. */
      200: {
        content: {
          "application/json": {
            pagination: components["schemas"]["Pagination"];
            secrets: ({
                /**
                 * Format: date-time
                 * @description The date when the secret was created.
                 */
                created: string;
                /** @description Timestamp for when the secret was created. */
                createdAt?: number;
                /** @description Indicates whether the secret value can be decrypted after it has been created. */
                decryptable?: boolean;
                /** @description The name of the secret. */
                name: string;
                /** @description The unique identifier of the project which the secret belongs to. */
                projectId?: string;
                /** @description The unique identifier of the team the secret was created for. */
                teamId?: string | null;
                /** @description The unique identifier of the secret. */
                uid: string;
                /** @description The unique identifier of the user who created the secret. */
                userId?: string;
                /** @description The value of the secret. */
                value?: string;
              })[];
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Get a single secret
   * @description Retrieves the information for a specific secret by passing either the secret id or name in the URL.
   */
  getSecret: {
    parameters: {
      query?: {
        /** @description Whether to try to decrypt the value of the secret. Only works if `decryptable` has been set to `true` when the secret was created. */
        decrypt?: "true" | "false";
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The name or the unique identifier to which the secret belongs to. */
        idOrName: string;
      };
    };
    responses: {
      /** @description Successful response retrieving a secret. */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The date when the secret was created.
             */
            created: string;
            /** @description Timestamp for when the secret was created. */
            createdAt?: number;
            /** @description Indicates whether the secret value can be decrypted after it has been created. */
            decryptable?: boolean;
            /** @description The name of the secret. */
            name: string;
            /** @description The unique identifier of the project which the secret belongs to. */
            projectId?: string;
            /** @description The unique identifier of the team the secret was created for. */
            teamId?: string | null;
            /** @description The unique identifier of the secret. */
            uid: string;
            /** @description The unique identifier of the user who created the secret. */
            userId?: string;
            /** @description The value of the secret. */
            value?: string;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Create an Auth Token
   * @description Creates and returns a new authentication token for the currently authenticated User. The `bearerToken` property is only provided once, in the response body, so be sure to save it on the client for use with API requests.
   */
  createAuthToken: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": OneOf<[{
          expiresAt?: number;
          name: string;
        }, {
          clientId?: string;
          expiresAt?: number;
          installationId?: string;
          name: string;
          /** @enum {unknown} */
          type: "oauth2-token";
        }]>;
      };
    };
    responses: {
      /** @description Successful response. */
      200: {
        content: {
          "application/json": {
            /** @description The authentication token's actual value. This token is only provided in this response, and can never be retrieved again in the future. Be sure to save it somewhere safe! */
            bearerToken: string;
            token: components["schemas"]["AuthToken"];
          };
        };
      };
      /** @description One of the provided values in the request body is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Delete an authentication token
   * @description Invalidate an authentication token, such that it will no longer be valid for future HTTP requests.
   */
  deleteAuthToken: {
    parameters: {
      path: {
        /** @description The identifier of the token to invalidate. The special value \"current\" may be supplied, which invalidates the token that the HTTP request was authenticated with. */
        tokenId: string;
      };
    };
    responses: {
      /** @description Authentication token successfully deleted. */
      200: {
        content: {
          "application/json": {
            /** @description The unique identifier of the token that was deleted. */
            tokenId: string;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description Token not found with the requested `tokenId`. */
      404: {
        content: never;
      };
    };
  };
  /**
   * List aliases
   * @description Retrieves a list of aliases for the authenticated User or Team. When `domain` is provided, only aliases for that domain will be returned. When `projectId` is provided, it will only return the given project aliases.
   */
  listAliases: {
    parameters: {
      query?: {
        /** @description Get only aliases of the given domain name */
        domain?: unknown[] | string;
        /** @description Get only aliases created after the provided timestamp */
        from?: number;
        /** @description Maximum number of aliases to list from a request */
        limit?: number;
        /** @description Filter aliases from the given `projectId` */
        projectId?: string;
        /** @description Get aliases created after this JavaScript timestamp */
        since?: number;
        /** @description Get aliases created before this JavaScript timestamp */
        until?: number;
        /** @description Get aliases that would be rolled back for the given deployment */
        rollbackDeploymentId?: string;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      /** @description The paginated list of aliases */
      200: {
        content: {
          "application/json": {
            aliases: ({
                /** @description The alias name, it could be a `.vercel.app` subdomain or a custom domain */
                alias: string;
                /**
                 * Format: date-time
                 * @description The date when the alias was created
                 */
                created: string;
                /** @description The date when the alias was created in milliseconds since the UNIX epoch */
                createdAt?: number;
                /** @description Information of the user who created the alias */
                creator?: {
                  /** @description Email of the user who created the alias */
                  email: string;
                  /** @description ID of the user who created the alias */
                  uid: string;
                  /** @description Username of the user who created the alias */
                  username: string;
                };
                /** @description The date when the alias was deleted in milliseconds since the UNIX epoch */
                deletedAt?: number;
                /** @description A map with the deployment ID, URL and metadata */
                deployment?: {
                  /** @description The deployment unique identifier */
                  id: string;
                  /** @description The deployment metadata */
                  meta?: string;
                  /** @description The deployment unique URL */
                  url: string;
                };
                /** @description The deployment ID */
                deploymentId: string | null;
                /** @description The unique identifier of the project */
                projectId: string | null;
                /** @description Construct a type with a set of properties K of type T */
                protectionBypass?: {
                  [key: string]: string;
                };
                /** @description Target destination domain for redirect when the alias is a redirect */
                redirect?: string | null;
                /**
                 * @description Status code to be used on redirect
                 * @enum {number|null}
                 */
                redirectStatusCode?: 301 | 302 | 307 | 308;
                /** @description The unique identifier of the alias */
                uid: string;
                /** @description The date when the alias was updated in milliseconds since the UNIX epoch */
                updatedAt?: number;
              })[];
            pagination: components["schemas"]["Pagination"];
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Get an Alias
   * @description Retrieves an Alias for the given host name or alias ID.
   */
  getAlias: {
    parameters: {
      query?: {
        /** @description Get the alias only if it was created after the provided timestamp */
        from?: number;
        /** @description Get the alias only if it is assigned to the provided project ID */
        projectId?: string;
        /** @description Get the alias only if it was created after this JavaScript timestamp */
        since?: number;
        /** @description Get the alias only if it was created before this JavaScript timestamp */
        until?: number;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The alias or alias ID to be retrieved */
        idOrAlias: string;
      };
    };
    responses: {
      /** @description The alias information */
      200: {
        content: {
          "application/json": {
            /** @description The alias name, it could be a `.vercel.app` subdomain or a custom domain */
            alias: string;
            /**
             * Format: date-time
             * @description The date when the alias was created
             */
            created: string;
            /** @description The date when the alias was created in milliseconds since the UNIX epoch */
            createdAt?: number;
            /** @description Information of the user who created the alias */
            creator?: {
              /** @description Email of the user who created the alias */
              email: string;
              /** @description ID of the user who created the alias */
              uid: string;
              /** @description Username of the user who created the alias */
              username: string;
            };
            /** @description The date when the alias was deleted in milliseconds since the UNIX epoch */
            deletedAt?: number;
            /** @description A map with the deployment ID, URL and metadata */
            deployment?: {
              /** @description The deployment unique identifier */
              id: string;
              /** @description The deployment metadata */
              meta?: string;
              /** @description The deployment unique URL */
              url: string;
            };
            /** @description The deployment ID */
            deploymentId: string | null;
            /** @description The unique identifier of the project */
            projectId: string | null;
            /** @description Construct a type with a set of properties K of type T */
            protectionBypass?: {
              [key: string]: string;
            };
            /** @description Target destination domain for redirect when the alias is a redirect */
            redirect?: string | null;
            /**
             * @description Status code to be used on redirect
             * @enum {number|null}
             */
            redirectStatusCode?: 301 | 302 | 307 | 308;
            /** @description The unique identifier of the alias */
            uid: string;
            /** @description The date when the alias was updated in milliseconds since the UNIX epoch */
            updatedAt?: number;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The alias was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Register or transfer-in a new Domain
   * @description This endpoint is used for registering a new domain name with Vercel for the authenticating user, and also for initiating a domain transfer request from an external Registrar to Vercel.
   */
  createOrTransferDomain: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": OneOf<[{
          /** @description The domain operation to perform. */
          method: string;
          /** @description The domain name you want to add. */
          name: string;
          /** @description The move-in token from Move Requested email. */
          token?: string;
        }, {
          /** @description The authorization code assigned to the domain. */
          authCode?: string;
          /** @description The price you expect to be charged for the required 1 year renewal. */
          expectedPrice?: number;
          /** @description The domain operation to perform. */
          method: string;
          /** @description The domain name you want to add. */
          name: string;
        }, {
          /** @description Whether the domain has the Vercel Edge Network enabled or not. */
          cdnEnabled?: boolean;
          /** @description The domain operation to perform. */
          method?: string;
          /** @description The domain name you want to add. */
          name: string;
        }]>;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            domain: {
              /** @description If it was purchased through Vercel, the timestamp in milliseconds when it was purchased. */
              boughtAt: number | null;
              /** @description Timestamp in milliseconds when the domain was created in the registry. */
              createdAt: number;
              /** @description An object containing information of the domain creator, including the user's id, username, and email. */
              creator: {
                customerId?: string | null;
                email: string;
                id: string;
                isDomainReseller?: boolean;
                username: string;
              };
              /** @description A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel. */
              customNameservers?: string[];
              /** @description Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel. */
              expiresAt: number | null;
              /** @description The unique identifier of the domain. */
              id: string;
              /** @description A list of the intended nameservers for the domain to point to Vercel DNS. */
              intendedNameservers: string[];
              /** @description The domain name. */
              name: string;
              /** @description A list of the current nameservers of the domain. */
              nameservers: string[];
              /** @description Timestamp in milliseconds at which the domain was ordered. */
              orderedAt?: number;
              /** @description Indicates whether the domain is set to automatically renew. */
              renew?: boolean;
              /**
               * @description The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
               * @enum {string}
               */
              serviceType: "zeit.world" | "external" | "na";
              /** @description If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated. */
              transferStartedAt?: number;
              /** @description Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in. */
              transferredAt?: number | null;
              /** @description If the domain has the ownership verified. */
              verified: boolean;
            };
          };
        };
      };
      /** @description One of the provided values in the request body is invalid. */
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
      409: {
        content: never;
      };
    };
  };
  /**
   * Purchase a domain
   * @description Allows to purchase the specified domain.
   */
  buyDomain: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description The price you expect to be charged for the purchase. */
          expectedPrice?: number;
          /** @description The domain name to purchase. */
          name: string;
          /** @description Indicates whether the domain should be automatically renewed. */
          renew?: boolean;
        };
      };
    };
    responses: {
      /** @description Successful response for purchasing a Domain. */
      201: {
        content: {
          "application/json": {
            domain: {
              created: number;
              ns: string[];
              pending: boolean;
              uid: string;
              verified: boolean;
            };
          };
        };
      };
      /** @description One of the provided values in the request body is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      409: {
        content: never;
      };
      429: {
        content: never;
      };
    };
  };
  /**
   * Check the price for a domain
   * @description Check the price to purchase a domain and how long a single purchase period is.
   */
  checkDomainPrice: {
    parameters: {
      query: {
        /** @description The name of the domain for which the price needs to be checked. */
        name: string;
        /** @description In which status of the domain the price needs to be checked. */
        type?: "new" | "renewal";
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      /** @description Successful response which returns the price of the domain and the period. */
      200: {
        content: {
          "application/json": {
            /** @description The number of years the domain could be held before paying again. */
            period: number;
            /** @description The domain price in USD. */
            price: number;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Check a Domain Availability
   * @description Check if a domain name is available for purchase.
   */
  checkDomainStatus: {
    parameters: {
      query: {
        /** @description The name of the domain for which we would like to check the status. */
        name: string;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      /** @description Successful response checking if a Domain's name is available. */
      200: {
        content: {
          "application/json": {
            available: boolean;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * List existing DNS records
   * @description Retrieves a list of DNS records created for a domain name. By default it returns 20 records if no limit is provided. The rest can be retrieved using the pagination options.
   */
  getRecords: {
    parameters: {
      query?: {
        /** @description Maximum number of records to list from a request. */
        limit?: string;
        /** @description Get records created after this JavaScript timestamp. */
        since?: string;
        /** @description Get records created before this JavaScript timestamp. */
        until?: string;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        domain: string;
      };
    };
    responses: {
      /** @description Successful response retrieving a list of paginated DNS records. */
      200: {
        content: {
          "application/json": OneOf<[string, {
            records: ({
                created: number | null;
                createdAt: number | null;
                creator: string;
                id: string;
                mxPriority?: number;
                name: string;
                priority?: number;
                slug: string;
                /** @enum {string} */
                type: "A" | "AAAA" | "ALIAS" | "CAA" | "CNAME" | "MX" | "SRV" | "TXT" | "NS";
                updated: number | null;
                updatedAt: number | null;
                value: string;
              })[];
          }, {
            pagination: components["schemas"]["Pagination"];
            records: ({
                created: number | null;
                createdAt: number | null;
                creator: string;
                id: string;
                mxPriority?: number;
                name: string;
                priority?: number;
                slug: string;
                /** @enum {string} */
                type: "A" | "AAAA" | "ALIAS" | "CAA" | "CNAME" | "MX" | "SRV" | "TXT" | "NS";
                updated: number | null;
                updatedAt: number | null;
                value: string;
              })[];
          }]>;
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      401: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * List all the domains
   * @description Retrieves a list of domains registered for the authenticating user. By default it returns the last 20 domains if no limit is provided.
   */
  getDomains: {
    parameters: {
      query?: {
        /** @description Maximum number of domains to list from a request. */
        limit?: number;
        /** @description Get domains created after this JavaScript timestamp. */
        since?: number;
        /** @description Get domains created before this JavaScript timestamp. */
        until?: number;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      /** @description Successful response retrieving a list of domains. */
      200: {
        content: {
          "application/json": {
            domains: ({
                /** @description If it was purchased through Vercel, the timestamp in milliseconds when it was purchased. */
                boughtAt: number | null;
                /** @description Timestamp in milliseconds when the domain was created in the registry. */
                createdAt: number;
                /** @description An object containing information of the domain creator, including the user's id, username, and email. */
                creator: {
                  customerId?: string | null;
                  email: string;
                  id: string;
                  isDomainReseller?: boolean;
                  username: string;
                };
                /** @description A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel. */
                customNameservers?: string[];
                /** @description Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel. */
                expiresAt: number | null;
                /** @description The unique identifier of the domain. */
                id: string;
                /** @description A list of the intended nameservers for the domain to point to Vercel DNS. */
                intendedNameservers: string[];
                /** @description The domain name. */
                name: string;
                /** @description A list of the current nameservers of the domain. */
                nameservers: string[];
                /** @description Timestamp in milliseconds at which the domain was ordered. */
                orderedAt?: number;
                /** @description Indicates whether the domain is set to automatically renew. */
                renew?: boolean;
                /**
                 * @description The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
                 * @enum {string}
                 */
                serviceType: "zeit.world" | "external" | "na";
                /** @description If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated. */
                transferStartedAt?: number;
                /** @description Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in. */
                transferredAt?: number | null;
                /** @description If the domain has the ownership verified. */
                verified: boolean;
              })[];
            pagination: components["schemas"]["Pagination"];
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      409: {
        content: never;
      };
    };
  };
  /**
   * Get Information for a Single Domain
   * @description Get information for a single domain in an account or team.
   */
  getDomain: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The name of the domain. */
        domain: string;
      };
    };
    responses: {
      /** @description Successful response retrieving an information for a specific domains. */
      200: {
        content: {
          "application/json": {
            domain: {
              /** @description If it was purchased through Vercel, the timestamp in milliseconds when it was purchased. */
              boughtAt: number | null;
              /** @description Timestamp in milliseconds when the domain was created in the registry. */
              createdAt: number;
              /** @description An object containing information of the domain creator, including the user's id, username, and email. */
              creator: {
                customerId?: string | null;
                email: string;
                id: string;
                isDomainReseller?: boolean;
                username: string;
              };
              /** @description A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel. */
              customNameservers?: string[];
              /** @description Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel. */
              expiresAt: number | null;
              /** @description The unique identifier of the domain. */
              id: string;
              /** @description A list of the intended nameservers for the domain to point to Vercel DNS. */
              intendedNameservers: string[];
              /** @description The domain name. */
              name: string;
              /** @description A list of the current nameservers of the domain. */
              nameservers: string[];
              /** @description Timestamp in milliseconds at which the domain was ordered. */
              orderedAt?: number;
              /** @description Indicates whether the domain is set to automatically renew. */
              renew?: boolean;
              /**
               * @description The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
               * @enum {string}
               */
              serviceType: "zeit.world" | "external" | "na";
              suffix: boolean;
              /** @description If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated. */
              transferStartedAt?: number;
              /** @description Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in. */
              transferredAt?: number | null;
              /** @description If the domain has the ownership verified. */
              verified: boolean;
            };
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * List Auth Tokens
   * @description Retrieve a list of the current User's authentication tokens.
   */
  listAuthTokens: {
    responses: {
      200: {
        content: {
          "application/json": {
            pagination: components["schemas"]["Pagination"];
            testingToken: components["schemas"]["AuthToken"];
            tokens: components["schemas"]["AuthToken"][];
          };
        };
      };
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Get Auth Token Metadata
   * @description Retrieve metadata about an authentication token belonging to the currently authenticated User.
   */
  getAuthToken: {
    parameters: {
      path: {
        /** @description The identifier of the token to retrieve. The special value \"current\" may be supplied, which returns the metadata for the token that the current HTTP request is authenticated with. */
        tokenId: string;
      };
    };
    responses: {
      /** @description Successful response. */
      200: {
        content: {
          "application/json": {
            token: components["schemas"]["AuthToken"];
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description Token not found with the requested `tokenId`. */
      404: {
        content: never;
      };
    };
  };
  /**
   * List deployments
   * @description List deployments under the account corresponding to the API token. If a deployment hasn't finished uploading (is incomplete), the `url` property will have a value of `null`.
   */
  getDeployments: {
    parameters: {
      query?: {
        /** @description Name of the deployment. */
        app?: string;
        /** @description Gets the deployment created after this Date timestamp. (default: current time) */
        from?: number;
        /** @description Maximum number of deployments to list from a request. */
        limit?: number;
        /** @description Filter deployments from the given `projectId`. */
        projectId?: string;
        /** @description Filter deployments based on the environment. */
        target?: "production" | "preview";
        /** @description Gets the deployment created before this Date timestamp. (default: current time) */
        to?: number;
        /** @description Filter out deployments based on users who have created the deployment. */
        users?: string;
        /** @description Get Deployments created after this JavaScript timestamp. */
        since?: number;
        /** @description Get Deployments created before this JavaScript timestamp. */
        until?: number;
        /** @description Filter deployments based on their state (`BUILDING`, `ERROR`, `INITIALIZING`, `QUEUED`, `READY`, `CANCELED`) */
        state?: string;
        /** @description Filter deployments based on their rollback candidacy */
        rollbackCandidate?: boolean;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            deployments: ({
                aliasAssigned?: number | boolean;
                /** @description An error object in case aliasing of the deployment failed. */
                aliasError?: {
                  code: string;
                  message: string;
                } | null;
                /** @description Timestamp of when the deployment started building at. */
                buildingAt?: number;
                /**
                 * @description Conclusion for checks
                 * @enum {string}
                 */
                checksConclusion?: "succeeded" | "failed" | "skipped" | "canceled";
                /**
                 * @description State of all registered checks
                 * @enum {string}
                 */
                checksState?: "registered" | "running" | "completed";
                /** @description Timestamp of when the deployment got created. */
                created: number;
                /** @description Timestamp of when the deployment got created. */
                createdAt?: number;
                /** @description Metadata information of the user who created the deployment. */
                creator: {
                  /** @description The email address of the user. */
                  email?: string;
                  /** @description The GitHub login of the user. */
                  githubLogin?: string;
                  /** @description The GitLab login of the user. */
                  gitlabLogin?: string;
                  /** @description The unique identifier of the user. */
                  uid: string;
                  /** @description The username of the user. */
                  username?: string;
                };
                /** @description Vercel URL to inspect the deployment. */
                inspectorUrl: string | null;
                /** @description Deployment can be used for instant rollback */
                isRollbackCandidate?: boolean | null;
                /** @description An object containing the deployment's metadata */
                meta?: {
                  [key: string]: string;
                };
                /** @description The name of the deployment. */
                name: string;
                /** @description Timestamp of when the deployment got ready. */
                ready?: number;
                /**
                 * @description The source of the deployment.
                 * @enum {string}
                 */
                source?: "cli" | "git" | "import" | "import/repo" | "clone/repo";
                /**
                 * @description In which state is the deployment.
                 * @enum {string}
                 */
                state?: "BUILDING" | "ERROR" | "INITIALIZING" | "QUEUED" | "READY" | "CANCELED";
                /**
                 * @description On which environment has the deployment been deployed to.
                 * @enum {string|null}
                 */
                target?: "production" | "staging";
                /**
                 * @description The type of the deployment.
                 * @enum {string}
                 */
                type: "LAMBDAS";
                /** @description The unique identifier of the deployment. */
                uid: string;
                /** @description The URL of the deployment. */
                url: string;
              })[];
            pagination: components["schemas"]["Pagination"];
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * List Deployment Files
   * @description Allows to retrieve the file structure of a deployment by supplying the deployment unique identifier.
   */
  listDeploymentFiles: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique deployment identifier */
        id: string;
      };
    };
    responses: {
      /** @description Retrieved the file tree successfully */
      200: {
        content: {
          "application/json": components["schemas"]["FileTree"][];
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /**
       * @description File tree not found
       * Deployment not found
       */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get Deployment File Contents
   * @description Allows to retrieve the content of a file by supplying the file identifier and the deployment unique identifier. The response body will contain the raw content of the file.
   */
  getDeploymentFileContents: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique deployment identifier */
        id: string;
        /** @description The unique file identifier */
        fileId: string;
      };
    };
    responses: {
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /**
       * @description File not found
       * Deployment not found
       */
      404: {
        content: never;
      };
    };
  };
  /**
   * Remove a domain by name
   * @description Delete a previously registered domain name from Vercel. Deleting a domain will automatically remove any associated aliases.
   */
  deleteDomain: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The name of the domain. */
        domain: string;
      };
    };
    responses: {
      /** @description Successful response removing a domain. */
      200: {
        content: {
          "application/json": {
            uid: string;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
      409: {
        content: never;
      };
    };
  };
  /**
   * Get a Domain's configuration
   * @description Get a Domain's configuration.
   */
  getDomainConfig: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The name of the domain. */
        domain: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            /** @description Which challenge types the domain can use for issuing certs. */
            acceptedChallenges?: ("dns-01" | "http-01")[];
            /**
             * @description How we see the domain's configuration. - `CNAME`: Domain has a CNAME pointing to Vercel. - `A`: Domain's A record is resolving to Vercel. - `http`: Domain is resolving to Vercel but may be behind a Proxy. - `null`: Domain is not resolving to Vercel.
             * @enum {string|null}
             */
            configuredBy?: "CNAME" | "A" | "http";
            /** @description Whether or not the domain is configured AND we can automatically generate a TLS certificate. */
            misconfigured: boolean;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Upload a cert
   * @description Upload a cert
   */
  uploadCert: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description The certificate authority */
          ca: string;
          /** @description The certificate */
          cert: string;
          /** @description The certificate key */
          key: string;
          /** @description Skip validation of the certificate */
          skipValidation?: boolean;
        };
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            autoRenew: boolean;
            cns: string[];
            createdAt: number;
            expiresAt: number;
            id: string;
          };
        };
      };
      /** @description One of the provided values in the request body is invalid. */
      400: {
        content: never;
      };
      /**
       * @description This feature is only available for Enterprise customers.
       * This feature is optionally available for advanced use cases. Contact Sales: https://vercel.com/contact/sales
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Issue a new cert
   * @description Issue a new cert
   */
  issueCert: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description The common names the cert should be issued for */
          cns?: string[];
        };
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            autoRenew: boolean;
            cns: string[];
            createdAt: number;
            expiresAt: number;
            id: string;
          };
        };
      };
      /** @description One of the provided values in the request body is invalid. */
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
      429: {
        content: never;
      };
      449: {
        content: never;
      };
      500: {
        content: never;
      };
    };
  };
  /**
   * Get cert by id
   * @description Get cert by id
   */
  getCertById: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The cert id */
        id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            autoRenew: boolean;
            cns: string[];
            createdAt: number;
            expiresAt: number;
            id: string;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Remove cert
   * @description Remove cert
   */
  removeCert: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The cert id to remove */
        id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Query information about an artifact
   * @description Query information about an array of artifacts.
   */
  artifactQuery: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description artifact hashes */
          hashes: string[];
        };
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            [key: string]: OneOf<[{
              size: number;
              tag?: string;
              taskDurationMs: number;
            }, {
              message: string;
              name: string;
              stack?: string;
            }]>;
          };
        };
      };
      /** @description One of the provided values in the request body is invalid. */
      400: {
        content: never;
      };
      /**
       * @description Invalid token
       * The request is missing an authentication token
       */
      401: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /**
       * @description The customer has reached their spend cap limit and has been paused. An owner can disable the cap or raise the limit in settings.
       * The Remote Caching usage limit has been reached for this account for this billing cycle.
       * Remote Caching has been disabled for this team or user. An owner can enable it in the billing settings.
       * You do not have permission to access this resource.
       */
      403: {
        content: never;
      };
    };
  };
  /**
   * Record an artifacts cache usage event
   * @description Records an artifacts cache usage event. The body of this request is an array of cache usage events. The supported event types are `HIT` and `MISS`. The source is either `LOCAL` the cache event was on the users filesystem cache or `REMOTE` if the cache event is for a remote cache. When the event is a `HIT` the request also accepts a number `duration` which is the time taken to generate the artifact in the cache.
   */
  recordEvents: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      header?: {
        /** @description The continuous integration or delivery environment where this artifact is downloaded. */
        "x-artifact-client-ci"?: string;
        /** @description 1 if the client is an interactive shell. Otherwise 0 */
        "x-artifact-client-interactive"?: number;
      };
    };
    requestBody?: {
      content: {
        "application/json": ({
            /** @description The time taken to generate the artifact. This should be sent as a body parameter on `HIT` events. */
            duration?: number;
            /**
             * @description One of `HIT` or `MISS`. `HIT` specifies that a cached artifact for `hash` was found in the cache. `MISS` specifies that a cached artifact with `hash` was not found.
             * @enum {string}
             */
            event: "HIT" | "MISS";
            /** @description The artifact hash */
            hash: string;
            /** @description A UUID (universally unique identifer) for the session that generated this event. */
            sessionId: string;
            /**
             * @description One of `LOCAL` or `REMOTE`. `LOCAL` specifies that the cache event was from the user's filesystem cache. `REMOTE` specifies that the cache event is from a remote cache.
             * @enum {string}
             */
            source: "LOCAL" | "REMOTE";
          })[];
      };
    };
    responses: {
      /** @description Success. Event recorded. */
      200: {
        content: never;
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the headers is invalid
       */
      400: {
        content: never;
      };
      /**
       * @description Invalid token
       * The request is missing an authentication token
       */
      401: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /**
       * @description The customer has reached their spend cap limit and has been paused. An owner can disable the cap or raise the limit in settings.
       * The Remote Caching usage limit has been reached for this account for this billing cycle.
       * Remote Caching has been disabled for this team or user. An owner can enable it in the billing settings.
       * You do not have permission to access this resource.
       */
      403: {
        content: never;
      };
    };
  };
  /**
   * Get status of Remote Caching for this principal
   * @description Check the status of Remote Caching for this principal. Returns a JSON-encoded status indicating if Remote Caching is enabled, disabled, or disabled due to usage limits.
   */
  status: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            /** @enum {string} */
            status: "disabled" | "enabled" | "over_limit" | "paused";
          };
        };
      };
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Download a cache artifact
   * @description Downloads a cache artifact indentified by its `hash` specified on the request path. The artifact is downloaded as an octet-stream. The client should verify the content-length header and response body.
   */
  downloadArtifact: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      header?: {
        /** @description The continuous integration or delivery environment where this artifact is downloaded. */
        "x-artifact-client-ci"?: string;
        /** @description 1 if the client is an interactive shell. Otherwise 0 */
        "x-artifact-client-interactive"?: number;
      };
      path: {
        /** @description The artifact hash */
        hash: string;
      };
    };
    responses: {
      /** @description The artifact was found and is downloaded as a stream. Content-Length should be verified. */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /**
       * @description One of the provided values in the request query is invalid.
       * One of the provided values in the headers is invalid
       */
      400: {
        content: never;
      };
      /**
       * @description Invalid token
       * The request is missing an authentication token
       */
      401: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /**
       * @description The customer has reached their spend cap limit and has been paused. An owner can disable the cap or raise the limit in settings.
       * The Remote Caching usage limit has been reached for this account for this billing cycle.
       * Remote Caching has been disabled for this team or user. An owner can enable it in the billing settings.
       * You do not have permission to access this resource.
       */
      403: {
        content: never;
      };
      /** @description The artifact was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Upload a cache artifact
   * @description Uploads a cache artifact identified by the `hash` specified on the path. The cache artifact can then be downloaded with the provided `hash`.
   */
  uploadArtifact: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      header: {
        /** @description The artifact size in bytes */
        "Content-Length": number;
        /** @description The time taken to generate the uploaded artifact in milliseconds. */
        "x-artifact-duration"?: number;
        /** @description The continuous integration or delivery environment where this artifact was generated. */
        "x-artifact-client-ci"?: string;
        /** @description 1 if the client is an interactive shell. Otherwise 0 */
        "x-artifact-client-interactive"?: number;
        /** @description The base64 encoded tag for this artifact. The value is sent back to clients when the artifact is downloaded as the header `x-artifact-tag` */
        "x-artifact-tag"?: string;
      };
      path: {
        /** @description The artifact hash */
        hash: string;
      };
    };
    requestBody?: {
      content: {
        "application/octet-stream": unknown;
      };
    };
    responses: {
      /** @description File successfully uploaded */
      202: {
        content: {
          "application/json": {
            /** @description Array of URLs where the artifact was updated */
            urls: string[];
          };
        };
      };
      /**
       * @description One of the provided values in the request query is invalid.
       * One of the provided values in the headers is invalid
       * File size is not valid
       */
      400: {
        content: never;
      };
      /**
       * @description Invalid token
       * The request is missing an authentication token
       */
      401: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /**
       * @description The customer has reached their spend cap limit and has been paused. An owner can disable the cap or raise the limit in settings.
       * The Remote Caching usage limit has been reached for this account for this billing cycle.
       * Remote Caching has been disabled for this team or user. An owner can enable it in the billing settings.
       * You do not have permission to access this resource.
       */
      403: {
        content: never;
      };
    };
  };
  /**
   * Check if a cache artifact exists
   * @description Check that a cache artifact with the given `hash` exists. This request returns response headers only and is equivalent to a `GET` request to this endpoint where the response contains no body.
   */
  artifactExists: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The artifact hash */
        hash: string;
      };
    };
    responses: {
      /** @description The artifact was found and headers are returned */
      200: {
        content: never;
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /**
       * @description Invalid token
       * The request is missing an authentication token
       */
      401: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /**
       * @description The customer has reached their spend cap limit and has been paused. An owner can disable the cap or raise the limit in settings.
       * The Remote Caching usage limit has been reached for this account for this billing cycle.
       * Remote Caching has been disabled for this team or user. An owner can enable it in the billing settings.
       * You do not have permission to access this resource.
       */
      403: {
        content: never;
      };
      /** @description The artifact was not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Retrieve a list of projects
   * @description Allows to retrieve the list of projects of the authenticated user. The list will be paginated and the provided query parameters allow filtering the returned projects.
   */
  getProjects: {
    parameters: {
      query?: {
        /** @description Query only projects updated after the given timestamp */
        from?: string;
        /** @description Specifies whether PRs from Git forks should require a team member's authorization before it can be deployed */
        gitForkProtection?: "1" | "0";
        /** @description Limit the number of projects returned */
        limit?: string;
        /** @description Search projects by the name field */
        search?: string;
        /** @description Filter results by repo. Also used for project count */
        repo?: string;
        /** @description Filter results by Repository ID. */
        repoId?: string;
        /** @description Filter results by Repository URL. */
        repoUrl?: string;
        /** @description Filter results by excluding those projects that belong to a repo */
        excludeRepos?: string;
        /** @description Filter results by connected Edge Config ID */
        edgeConfigId?: string;
        /** @description Filter results by connected Edge Config Token ID */
        edgeConfigTokenId?: string;
        /** @description Filter results by linked Connect configuration ID */
        connectConfigurationId?: string;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    responses: {
      /** @description The paginated list of projects */
      200: {
        content: {
          "application/json": {
            pagination: components["schemas"]["Pagination"];
            projects: ({
                accountId: string;
                analytics?: {
                  canceledAt: number | null;
                  disabledAt: number;
                  enabledAt: number;
                  id: string;
                  paidAt?: number;
                  sampleRatePercent?: number | null;
                  spendLimitInDollars?: number | null;
                };
                autoExposeSystemEnvs?: boolean;
                buildCommand?: string | null;
                commandForIgnoringBuildStep?: string | null;
                connectConfigurationId?: string | null;
                createdAt?: number;
                devCommand?: string | null;
                directoryListing: boolean;
                enablePreviewFeedback?: boolean | null;
                env?: ({
                    configurationId?: string | null;
                    createdAt?: number;
                    createdBy?: string | null;
                    /** @description Whether `value` is decrypted. */
                    decrypted?: boolean;
                    edgeConfigId?: string | null;
                    edgeConfigTokenId?: string | null;
                    gitBranch?: string;
                    id?: string;
                    key: string;
                    target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
                    /** @enum {string} */
                    type: "secret" | "system" | "encrypted" | "plain" | "sensitive";
                    updatedAt?: number;
                    updatedBy?: string | null;
                    value: string;
                  })[];
                /** @enum {string|null} */
                framework?: "blitzjs" | "nextjs" | "gatsby" | "remix" | "astro" | "hexo" | "eleventy" | "docusaurus-2" | "docusaurus" | "preact" | "solidstart" | "dojo" | "ember" | "vue" | "scully" | "ionic-angular" | "angular" | "polymer" | "svelte" | "sveltekit" | "sveltekit-1" | "ionic-react" | "create-react-app" | "gridsome" | "umijs" | "sapper" | "saber" | "stencil" | "nuxtjs" | "redwoodjs" | "hugo" | "jekyll" | "brunch" | "middleman" | "zola" | "hydrogen" | "vite" | "vitepress" | "vuepress" | "parcel" | "sanity";
                gitForkProtection?: boolean;
                hasFloatingAliases?: boolean;
                id: string;
                installCommand?: string | null;
                lastRollbackTarget?: ({
                  fromDeploymentId: string;
                  /** @enum {string} */
                  jobStatus: "succeeded" | "failed" | "skipped" | "pending" | "in-progress";
                  requestedAt: number;
                  toDeploymentId: string;
                }) | null;
                latestDeployments?: ({
                    alias?: string[];
                    aliasAssigned?: number | boolean;
                    aliasError?: {
                      code: string;
                      message: string;
                    } | null;
                    aliasFinal?: string | null;
                    automaticAliases?: string[];
                    buildingAt?: number;
                    builds?: {
                        dest?: string;
                        src?: string;
                        use: string;
                      }[];
                    /** @enum {string} */
                    checksConclusion?: "succeeded" | "failed" | "skipped" | "canceled";
                    /** @enum {string} */
                    checksState?: "registered" | "running" | "completed";
                    createdAt: number;
                    createdIn: string;
                    creator: {
                      email: string;
                      githubLogin?: string;
                      gitlabLogin?: string;
                      uid: string;
                      username: string;
                    } | null;
                    deploymentHostname: string;
                    forced?: boolean;
                    id: string;
                    /** @description Construct a type with a set of properties K of type T */
                    meta?: {
                      [key: string]: string;
                    };
                    monorepoManager?: string | null;
                    name: string;
                    /** @enum {string} */
                    plan: "hobby" | "enterprise" | "pro" | "oss";
                    /** @description Whether or not preview comments are enabled for the deployment */
                    previewCommentsEnabled?: boolean;
                    private: boolean;
                    readyAt?: number;
                    /** @enum {string} */
                    readyState: "BUILDING" | "ERROR" | "INITIALIZING" | "QUEUED" | "READY" | "CANCELED";
                    requestedAt?: number;
                    target?: string | null;
                    teamId?: string | null;
                    /** @enum {string} */
                    type: "LAMBDAS";
                    url: string;
                    userId: string;
                    withCache?: boolean;
                  })[];
                link?: OneOf<[{
                  createdAt?: number;
                  deployHooks: {
                      createdAt?: number;
                      id: string;
                      name: string;
                      ref: string;
                      url: string;
                    }[];
                  gitCredentialId?: string;
                  org?: string;
                  productionBranch?: string;
                  repo?: string;
                  repoId?: number;
                  sourceless?: boolean;
                  /** @enum {string} */
                  type?: "github";
                  updatedAt?: number;
                }, {
                  createdAt?: number;
                  deployHooks: {
                      createdAt?: number;
                      id: string;
                      name: string;
                      ref: string;
                      url: string;
                    }[];
                  gitCredentialId?: string;
                  productionBranch?: string;
                  projectId?: string;
                  projectName?: string;
                  projectNameWithNamespace?: string;
                  projectNamespace?: string;
                  projectUrl?: string;
                  sourceless?: boolean;
                  /** @enum {string} */
                  type?: "gitlab";
                  updatedAt?: number;
                }, {
                  createdAt?: number;
                  deployHooks: {
                      createdAt?: number;
                      id: string;
                      name: string;
                      ref: string;
                      url: string;
                    }[];
                  gitCredentialId?: string;
                  name?: string;
                  owner?: string;
                  productionBranch?: string;
                  slug?: string;
                  sourceless?: boolean;
                  /** @enum {string} */
                  type?: "bitbucket";
                  updatedAt?: number;
                  uuid?: string;
                  workspaceUuid?: string;
                }]>;
                live?: boolean;
                name: string;
                /** @enum {string} */
                nodeVersion: "18.x" | "16.x" | "14.x" | "12.x" | "10.x";
                outputDirectory?: string | null;
                passwordProtection?: ({
                  /** @enum {string} */
                  deploymentType: "preview" | "all";
                }) | null;
                permissions?: {
                  Monitoring?: components["schemas"]["ACLAction"][];
                  aliasGlobal?: components["schemas"]["ACLAction"][];
                  aliasProject?: components["schemas"]["ACLAction"][];
                  aliasProtectionBypass?: components["schemas"]["ACLAction"][];
                  analytics?: components["schemas"]["ACLAction"][];
                  analyticsSampling?: components["schemas"]["ACLAction"][];
                  analyticsUsage?: components["schemas"]["ACLAction"][];
                  auditLog?: components["schemas"]["ACLAction"][];
                  awsBillingIntegration?: components["schemas"]["ACLAction"][];
                  billingAddress?: components["schemas"]["ACLAction"][];
                  billingInformation?: components["schemas"]["ACLAction"][];
                  billingInvoice?: components["schemas"]["ACLAction"][];
                  billingInvoiceEmailRecipient?: components["schemas"]["ACLAction"][];
                  billingInvoiceLanguage?: components["schemas"]["ACLAction"][];
                  billingPlan?: components["schemas"]["ACLAction"][];
                  billingPurchaseOrder?: components["schemas"]["ACLAction"][];
                  billingTaxId?: components["schemas"]["ACLAction"][];
                  cacheArtifact?: components["schemas"]["ACLAction"][];
                  cacheArtifactUsageEvent?: components["schemas"]["ACLAction"][];
                  concurrentBuilds?: components["schemas"]["ACLAction"][];
                  connect?: components["schemas"]["ACLAction"][];
                  connectConfiguration?: components["schemas"]["ACLAction"][];
                  connectConfigurationLink?: components["schemas"]["ACLAction"][];
                  deployment?: components["schemas"]["ACLAction"][];
                  deploymentCheck?: components["schemas"]["ACLAction"][];
                  deploymentCheckPreview?: components["schemas"]["ACLAction"][];
                  deploymentPreview?: components["schemas"]["ACLAction"][];
                  deploymentPrivate?: components["schemas"]["ACLAction"][];
                  deploymentProductionGit?: components["schemas"]["ACLAction"][];
                  deploymentRollback?: components["schemas"]["ACLAction"][];
                  domain?: components["schemas"]["ACLAction"][];
                  domainAcceptDelegation?: components["schemas"]["ACLAction"][];
                  domainAuthCodes?: components["schemas"]["ACLAction"][];
                  domainCertificate?: components["schemas"]["ACLAction"][];
                  domainCheckConfig?: components["schemas"]["ACLAction"][];
                  domainMove?: components["schemas"]["ACLAction"][];
                  domainPurchase?: components["schemas"]["ACLAction"][];
                  domainRecord?: components["schemas"]["ACLAction"][];
                  domainTransferIn?: components["schemas"]["ACLAction"][];
                  edgeConfig?: components["schemas"]["ACLAction"][];
                  edgeConfigItem?: components["schemas"]["ACLAction"][];
                  edgeConfigToken?: components["schemas"]["ACLAction"][];
                  endpointVerification?: components["schemas"]["ACLAction"][];
                  event?: components["schemas"]["ACLAction"][];
                  fileUpload?: components["schemas"]["ACLAction"][];
                  gitRepository?: components["schemas"]["ACLAction"][];
                  integration?: components["schemas"]["ACLAction"][];
                  integrationConfiguration?: components["schemas"]["ACLAction"][];
                  integrationConfigurationProjects?: components["schemas"]["ACLAction"][];
                  integrationConfigurationTransfer?: components["schemas"]["ACLAction"][];
                  integrationVercelConfigurationOverride?: components["schemas"]["ACLAction"][];
                  job?: components["schemas"]["ACLAction"][];
                  logDrain?: components["schemas"]["ACLAction"][];
                  monitoringChart?: components["schemas"]["ACLAction"][];
                  monitoringQuery?: components["schemas"]["ACLAction"][];
                  notificationDomainConfiguration?: components["schemas"]["ACLAction"][];
                  notificationDomainExpire?: components["schemas"]["ACLAction"][];
                  notificationDomainMoved?: components["schemas"]["ACLAction"][];
                  notificationDomainPurchase?: components["schemas"]["ACLAction"][];
                  notificationDomainRenewal?: components["schemas"]["ACLAction"][];
                  notificationDomainTransfer?: components["schemas"]["ACLAction"][];
                  notificationDomainUnverified?: components["schemas"]["ACLAction"][];
                  notificationPaymentFailed?: components["schemas"]["ACLAction"][];
                  notificationSpendCap?: components["schemas"]["ACLAction"][];
                  notificationUsageAlert?: components["schemas"]["ACLAction"][];
                  openTelemetryEndpoint?: components["schemas"]["ACLAction"][];
                  passwordProtection?: components["schemas"]["ACLAction"][];
                  paymentMethod?: components["schemas"]["ACLAction"][];
                  permissions?: components["schemas"]["ACLAction"][];
                  previewDeploymentSuffix?: components["schemas"]["ACLAction"][];
                  proTrialOnboarding?: components["schemas"]["ACLAction"][];
                  project?: components["schemas"]["ACLAction"][];
                  projectDeploymentHook?: components["schemas"]["ACLAction"][];
                  projectDomain?: components["schemas"]["ACLAction"][];
                  projectDomainMove?: components["schemas"]["ACLAction"][];
                  projectEnvVars?: components["schemas"]["ACLAction"][];
                  projectEnvVarsProduction?: components["schemas"]["ACLAction"][];
                  projectEnvVarsUnownedByIntegration?: components["schemas"]["ACLAction"][];
                  projectIntegrationConfiguration?: components["schemas"]["ACLAction"][];
                  projectLink?: components["schemas"]["ACLAction"][];
                  projectMember?: components["schemas"]["ACLAction"][];
                  projectProductionBranch?: components["schemas"]["ACLAction"][];
                  projectProtectionBypass?: components["schemas"]["ACLAction"][];
                  projectTransfer?: components["schemas"]["ACLAction"][];
                  rateLimit?: components["schemas"]["ACLAction"][];
                  redis?: components["schemas"]["ACLAction"][];
                  remoteCaching?: components["schemas"]["ACLAction"][];
                  samlConfig?: components["schemas"]["ACLAction"][];
                  secret?: components["schemas"]["ACLAction"][];
                  sensitiveEnvironmentVariablePolicy?: components["schemas"]["ACLAction"][];
                  sharedEnvVars?: components["schemas"]["ACLAction"][];
                  sharedEnvVarsProduction?: components["schemas"]["ACLAction"][];
                  spendCapConfiguration?: components["schemas"]["ACLAction"][];
                  spendCapState?: components["schemas"]["ACLAction"][];
                  supportCase?: components["schemas"]["ACLAction"][];
                  supportCaseComment?: components["schemas"]["ACLAction"][];
                  team?: components["schemas"]["ACLAction"][];
                  teamAccessRequest?: components["schemas"]["ACLAction"][];
                  teamFellowMembership?: components["schemas"]["ACLAction"][];
                  teamInvite?: components["schemas"]["ACLAction"][];
                  teamInviteCode?: components["schemas"]["ACLAction"][];
                  teamJoin?: components["schemas"]["ACLAction"][];
                  teamOwnMembership?: components["schemas"]["ACLAction"][];
                  teamOwnMembershipDisconnectSAML?: components["schemas"]["ACLAction"][];
                  token?: components["schemas"]["ACLAction"][];
                  usage?: components["schemas"]["ACLAction"][];
                  user?: components["schemas"]["ACLAction"][];
                  userConnection?: components["schemas"]["ACLAction"][];
                  webAnalytics?: components["schemas"]["ACLAction"][];
                  webhook?: components["schemas"]["ACLAction"][];
                  "webhook-event"?: components["schemas"]["ACLAction"][];
                };
                /** @description Construct a type with a set of properties K of type T */
                protectionBypass?: {
                  [key: string]: string;
                };
                publicSource?: boolean | null;
                rootDirectory?: string | null;
                serverlessFunctionRegion?: string | null;
                skipGitConnectDuringLink?: boolean;
                sourceFilesOutsideRootDirectory?: boolean;
                ssoProtection?: ({
                  /** @enum {string} */
                  deploymentType: "preview" | "all";
                }) | null;
                /** @description An object containing the deployment's metadata */
                targets?: {
                  [key: string]: string;
                };
                transferCompletedAt?: number;
                transferStartedAt?: number;
                transferToAccountId?: string;
                transferredFromAccountId?: string;
                updatedAt?: number;
              })[];
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Create a new project
   * @description Allows to create a new project with the provided configuration. It only requires the project `name` but more configuration can be provided to override the defaults.
   */
  createProject: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description The build command for this project. When `null` is used this value will be automatically detected */
          buildCommand?: string | null;
          commandForIgnoringBuildStep?: string | null;
          /** @description The dev command for this project. When `null` is used this value will be automatically detected */
          devCommand?: string | null;
          /** @description Collection of ENV Variables the Project will use */
          environmentVariables?: ({
              /** @description The git branch of the environment variable */
              gitBranch?: string;
              /** @description Name of the ENV variable */
              key: string;
              /** @description Deployment Target or Targets in which the ENV variable will be used */
              target: ("mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Productio" | "mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Previe" | "mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Developmen") | (("mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Productio" | "mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Previe" | "mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Developmen")[]);
              /**
               * @description Type of the ENV variable
               * @enum {string}
               */
              type?: "system" | "secret" | "encrypted" | "plain";
              /** @description Value for the ENV variable */
              value: string;
            })[];
          /**
           * @description The framework that is being used for this project. When `null` is used no framework is selected
           * @enum {unknown}
           */
          framework?: "" | "blitzjs" | "nextjs" | "gatsby" | "remix" | "astro" | "hexo" | "eleventy" | "docusaurus-2" | "docusaurus" | "preact" | "solidstart" | "dojo" | "ember" | "vue" | "scully" | "ionic-angular" | "angular" | "polymer" | "svelte" | "sveltekit" | "sveltekit-1" | "ionic-react" | "create-react-app" | "gridsome" | "umijs" | "sapper" | "saber" | "stencil" | "nuxtjs" | "redwoodjs" | "hugo" | "jekyll" | "brunch" | "middleman" | "zola" | "hydrogen" | "vite" | "vitepress" | "vuepress" | "parcel" | "sanity";
          /** @description The Git Repository that will be connected to the project. When this is defined, any pushes to the specified connected Git Repository will be automatically deployed */
          gitRepository?: {
            /** @description The name of the git repository. For example: \"vercel/next.js\" */
            repo: string;
            /**
             * @description The Git Provider of the repository
             * @enum {unknown}
             */
            type: "github" | "gitlab" | "bitbucket";
          };
          /** @description The install command for this project. When `null` is used this value will be automatically detected */
          installCommand?: string | null;
          /** @description The desired name for the project */
          name: string;
          /** @description The output directory of the project. When `null` is used this value will be automatically detected */
          outputDirectory?: string | null;
          /** @description Specifies whether the source code and logs of the deployments for this project should be public or not */
          publicSource?: boolean | null;
          /** @description The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root */
          rootDirectory?: string | null;
          /** @description The region to deploy Serverless Functions in this project */
          serverlessFunctionRegion?: string | null;
          /**
           * @deprecated
           * @description Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.
           */
          skipGitConnectDuringLink?: boolean;
        };
      };
    };
    responses: {
      /** @description The project was successfuly created */
      200: {
        content: {
          "application/json": {
            accountId: string;
            analytics?: {
              canceledAt: number | null;
              disabledAt: number;
              enabledAt: number;
              id: string;
              paidAt?: number;
              sampleRatePercent?: number | null;
              spendLimitInDollars?: number | null;
            };
            autoExposeSystemEnvs?: boolean;
            buildCommand?: string | null;
            commandForIgnoringBuildStep?: string | null;
            connectConfigurationId?: string | null;
            createdAt?: number;
            devCommand?: string | null;
            directoryListing: boolean;
            enablePreviewFeedback?: boolean | null;
            env?: ({
                configurationId?: string | null;
                createdAt?: number;
                createdBy?: string | null;
                /** @description Whether `value` is decrypted. */
                decrypted?: boolean;
                edgeConfigId?: string | null;
                edgeConfigTokenId?: string | null;
                gitBranch?: string;
                id?: string;
                key: string;
                target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
                /** @enum {string} */
                type: "secret" | "system" | "encrypted" | "plain" | "sensitive";
                updatedAt?: number;
                updatedBy?: string | null;
                value: string;
              })[];
            /** @enum {string|null} */
            framework?: "blitzjs" | "nextjs" | "gatsby" | "remix" | "astro" | "hexo" | "eleventy" | "docusaurus-2" | "docusaurus" | "preact" | "solidstart" | "dojo" | "ember" | "vue" | "scully" | "ionic-angular" | "angular" | "polymer" | "svelte" | "sveltekit" | "sveltekit-1" | "ionic-react" | "create-react-app" | "gridsome" | "umijs" | "sapper" | "saber" | "stencil" | "nuxtjs" | "redwoodjs" | "hugo" | "jekyll" | "brunch" | "middleman" | "zola" | "hydrogen" | "vite" | "vitepress" | "vuepress" | "parcel" | "sanity";
            gitForkProtection?: boolean;
            hasFloatingAliases?: boolean;
            id: string;
            installCommand?: string | null;
            lastRollbackTarget?: ({
              fromDeploymentId: string;
              /** @enum {string} */
              jobStatus: "succeeded" | "failed" | "skipped" | "pending" | "in-progress";
              requestedAt: number;
              toDeploymentId: string;
            }) | null;
            latestDeployments?: ({
                alias?: string[];
                aliasAssigned?: number | boolean;
                aliasError?: {
                  code: string;
                  message: string;
                } | null;
                aliasFinal?: string | null;
                automaticAliases?: string[];
                buildingAt?: number;
                builds?: {
                    dest?: string;
                    src?: string;
                    use: string;
                  }[];
                /** @enum {string} */
                checksConclusion?: "succeeded" | "failed" | "skipped" | "canceled";
                /** @enum {string} */
                checksState?: "registered" | "running" | "completed";
                createdAt: number;
                createdIn: string;
                creator: {
                  email: string;
                  githubLogin?: string;
                  gitlabLogin?: string;
                  uid: string;
                  username: string;
                } | null;
                deploymentHostname: string;
                forced?: boolean;
                id: string;
                /** @description Construct a type with a set of properties K of type T */
                meta?: {
                  [key: string]: string;
                };
                monorepoManager?: string | null;
                name: string;
                /** @enum {string} */
                plan: "hobby" | "enterprise" | "pro" | "oss";
                /** @description Whether or not preview comments are enabled for the deployment */
                previewCommentsEnabled?: boolean;
                private: boolean;
                readyAt?: number;
                /** @enum {string} */
                readyState: "BUILDING" | "ERROR" | "INITIALIZING" | "QUEUED" | "READY" | "CANCELED";
                requestedAt?: number;
                target?: string | null;
                teamId?: string | null;
                /** @enum {string} */
                type: "LAMBDAS";
                url: string;
                userId: string;
                withCache?: boolean;
              })[];
            link?: OneOf<[{
              createdAt?: number;
              deployHooks: {
                  createdAt?: number;
                  id: string;
                  name: string;
                  ref: string;
                  url: string;
                }[];
              gitCredentialId?: string;
              org?: string;
              productionBranch?: string;
              repo?: string;
              repoId?: number;
              sourceless?: boolean;
              /** @enum {string} */
              type?: "github";
              updatedAt?: number;
            }, {
              createdAt?: number;
              deployHooks: {
                  createdAt?: number;
                  id: string;
                  name: string;
                  ref: string;
                  url: string;
                }[];
              gitCredentialId?: string;
              productionBranch?: string;
              projectId?: string;
              projectName?: string;
              projectNameWithNamespace?: string;
              projectNamespace?: string;
              projectUrl?: string;
              sourceless?: boolean;
              /** @enum {string} */
              type?: "gitlab";
              updatedAt?: number;
            }, {
              createdAt?: number;
              deployHooks: {
                  createdAt?: number;
                  id: string;
                  name: string;
                  ref: string;
                  url: string;
                }[];
              gitCredentialId?: string;
              name?: string;
              owner?: string;
              productionBranch?: string;
              slug?: string;
              sourceless?: boolean;
              /** @enum {string} */
              type?: "bitbucket";
              updatedAt?: number;
              uuid?: string;
              workspaceUuid?: string;
            }]>;
            live?: boolean;
            name: string;
            /** @enum {string} */
            nodeVersion: "18.x" | "16.x" | "14.x" | "12.x" | "10.x";
            outputDirectory?: string | null;
            passwordProtection?: ({
              /** @enum {string} */
              deploymentType: "preview" | "all";
            }) | null;
            permissions?: {
              Monitoring?: components["schemas"]["ACLAction"][];
              aliasGlobal?: components["schemas"]["ACLAction"][];
              aliasProject?: components["schemas"]["ACLAction"][];
              aliasProtectionBypass?: components["schemas"]["ACLAction"][];
              analytics?: components["schemas"]["ACLAction"][];
              analyticsSampling?: components["schemas"]["ACLAction"][];
              analyticsUsage?: components["schemas"]["ACLAction"][];
              auditLog?: components["schemas"]["ACLAction"][];
              awsBillingIntegration?: components["schemas"]["ACLAction"][];
              billingAddress?: components["schemas"]["ACLAction"][];
              billingInformation?: components["schemas"]["ACLAction"][];
              billingInvoice?: components["schemas"]["ACLAction"][];
              billingInvoiceEmailRecipient?: components["schemas"]["ACLAction"][];
              billingInvoiceLanguage?: components["schemas"]["ACLAction"][];
              billingPlan?: components["schemas"]["ACLAction"][];
              billingPurchaseOrder?: components["schemas"]["ACLAction"][];
              billingTaxId?: components["schemas"]["ACLAction"][];
              cacheArtifact?: components["schemas"]["ACLAction"][];
              cacheArtifactUsageEvent?: components["schemas"]["ACLAction"][];
              concurrentBuilds?: components["schemas"]["ACLAction"][];
              connect?: components["schemas"]["ACLAction"][];
              connectConfiguration?: components["schemas"]["ACLAction"][];
              connectConfigurationLink?: components["schemas"]["ACLAction"][];
              deployment?: components["schemas"]["ACLAction"][];
              deploymentCheck?: components["schemas"]["ACLAction"][];
              deploymentCheckPreview?: components["schemas"]["ACLAction"][];
              deploymentPreview?: components["schemas"]["ACLAction"][];
              deploymentPrivate?: components["schemas"]["ACLAction"][];
              deploymentProductionGit?: components["schemas"]["ACLAction"][];
              deploymentRollback?: components["schemas"]["ACLAction"][];
              domain?: components["schemas"]["ACLAction"][];
              domainAcceptDelegation?: components["schemas"]["ACLAction"][];
              domainAuthCodes?: components["schemas"]["ACLAction"][];
              domainCertificate?: components["schemas"]["ACLAction"][];
              domainCheckConfig?: components["schemas"]["ACLAction"][];
              domainMove?: components["schemas"]["ACLAction"][];
              domainPurchase?: components["schemas"]["ACLAction"][];
              domainRecord?: components["schemas"]["ACLAction"][];
              domainTransferIn?: components["schemas"]["ACLAction"][];
              edgeConfig?: components["schemas"]["ACLAction"][];
              edgeConfigItem?: components["schemas"]["ACLAction"][];
              edgeConfigToken?: components["schemas"]["ACLAction"][];
              endpointVerification?: components["schemas"]["ACLAction"][];
              event?: components["schemas"]["ACLAction"][];
              fileUpload?: components["schemas"]["ACLAction"][];
              gitRepository?: components["schemas"]["ACLAction"][];
              integration?: components["schemas"]["ACLAction"][];
              integrationConfiguration?: components["schemas"]["ACLAction"][];
              integrationConfigurationProjects?: components["schemas"]["ACLAction"][];
              integrationConfigurationTransfer?: components["schemas"]["ACLAction"][];
              integrationVercelConfigurationOverride?: components["schemas"]["ACLAction"][];
              job?: components["schemas"]["ACLAction"][];
              logDrain?: components["schemas"]["ACLAction"][];
              monitoringChart?: components["schemas"]["ACLAction"][];
              monitoringQuery?: components["schemas"]["ACLAction"][];
              notificationDomainConfiguration?: components["schemas"]["ACLAction"][];
              notificationDomainExpire?: components["schemas"]["ACLAction"][];
              notificationDomainMoved?: components["schemas"]["ACLAction"][];
              notificationDomainPurchase?: components["schemas"]["ACLAction"][];
              notificationDomainRenewal?: components["schemas"]["ACLAction"][];
              notificationDomainTransfer?: components["schemas"]["ACLAction"][];
              notificationDomainUnverified?: components["schemas"]["ACLAction"][];
              notificationPaymentFailed?: components["schemas"]["ACLAction"][];
              notificationSpendCap?: components["schemas"]["ACLAction"][];
              notificationUsageAlert?: components["schemas"]["ACLAction"][];
              openTelemetryEndpoint?: components["schemas"]["ACLAction"][];
              passwordProtection?: components["schemas"]["ACLAction"][];
              paymentMethod?: components["schemas"]["ACLAction"][];
              permissions?: components["schemas"]["ACLAction"][];
              previewDeploymentSuffix?: components["schemas"]["ACLAction"][];
              proTrialOnboarding?: components["schemas"]["ACLAction"][];
              project?: components["schemas"]["ACLAction"][];
              projectDeploymentHook?: components["schemas"]["ACLAction"][];
              projectDomain?: components["schemas"]["ACLAction"][];
              projectDomainMove?: components["schemas"]["ACLAction"][];
              projectEnvVars?: components["schemas"]["ACLAction"][];
              projectEnvVarsProduction?: components["schemas"]["ACLAction"][];
              projectEnvVarsUnownedByIntegration?: components["schemas"]["ACLAction"][];
              projectIntegrationConfiguration?: components["schemas"]["ACLAction"][];
              projectLink?: components["schemas"]["ACLAction"][];
              projectMember?: components["schemas"]["ACLAction"][];
              projectProductionBranch?: components["schemas"]["ACLAction"][];
              projectProtectionBypass?: components["schemas"]["ACLAction"][];
              projectTransfer?: components["schemas"]["ACLAction"][];
              rateLimit?: components["schemas"]["ACLAction"][];
              redis?: components["schemas"]["ACLAction"][];
              remoteCaching?: components["schemas"]["ACLAction"][];
              samlConfig?: components["schemas"]["ACLAction"][];
              secret?: components["schemas"]["ACLAction"][];
              sensitiveEnvironmentVariablePolicy?: components["schemas"]["ACLAction"][];
              sharedEnvVars?: components["schemas"]["ACLAction"][];
              sharedEnvVarsProduction?: components["schemas"]["ACLAction"][];
              spendCapConfiguration?: components["schemas"]["ACLAction"][];
              spendCapState?: components["schemas"]["ACLAction"][];
              supportCase?: components["schemas"]["ACLAction"][];
              supportCaseComment?: components["schemas"]["ACLAction"][];
              team?: components["schemas"]["ACLAction"][];
              teamAccessRequest?: components["schemas"]["ACLAction"][];
              teamFellowMembership?: components["schemas"]["ACLAction"][];
              teamInvite?: components["schemas"]["ACLAction"][];
              teamInviteCode?: components["schemas"]["ACLAction"][];
              teamJoin?: components["schemas"]["ACLAction"][];
              teamOwnMembership?: components["schemas"]["ACLAction"][];
              teamOwnMembershipDisconnectSAML?: components["schemas"]["ACLAction"][];
              token?: components["schemas"]["ACLAction"][];
              usage?: components["schemas"]["ACLAction"][];
              user?: components["schemas"]["ACLAction"][];
              userConnection?: components["schemas"]["ACLAction"][];
              webAnalytics?: components["schemas"]["ACLAction"][];
              webhook?: components["schemas"]["ACLAction"][];
              "webhook-event"?: components["schemas"]["ACLAction"][];
            };
            /** @description Construct a type with a set of properties K of type T */
            protectionBypass?: {
              [key: string]: string;
            };
            publicSource?: boolean | null;
            rootDirectory?: string | null;
            serverlessFunctionRegion?: string | null;
            skipGitConnectDuringLink?: boolean;
            sourceFilesOutsideRootDirectory?: boolean;
            ssoProtection?: ({
              /** @enum {string} */
              deploymentType: "preview" | "all";
            }) | null;
            /** @description An object containing the deployment's metadata */
            targets?: {
              [key: string]: string;
            };
            transferCompletedAt?: number;
            transferStartedAt?: number;
            transferToAccountId?: string;
            transferredFromAccountId?: string;
            updatedAt?: number;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       * The Bitbucket Webhook for the project link could not be created
       * The Gitlab Webhook for the project link could not be created
       */
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description A project with the provided name already exists. */
      409: {
        content: never;
      };
    };
  };
  /**
   * Find a project by id or name
   * @description Get the information for a specific project by passing either the project `id` or `name` in the URL.
   */
  getProject: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique project identifier or the project name */
        idOrName: string | boolean;
      };
    };
    responses: {
      /** @description The project information */
      200: {
        content: {
          "application/json": {
            accountId: string;
            analytics?: {
              canceledAt: number | null;
              disabledAt: number;
              enabledAt: number;
              id: string;
              paidAt?: number;
              sampleRatePercent?: number | null;
              spendLimitInDollars?: number | null;
            };
            autoExposeSystemEnvs?: boolean;
            buildCommand?: string | null;
            commandForIgnoringBuildStep?: string | null;
            connectConfigurationId?: string | null;
            createdAt?: number;
            devCommand?: string | null;
            directoryListing: boolean;
            enablePreviewFeedback?: boolean | null;
            env?: ({
                configurationId?: string | null;
                createdAt?: number;
                createdBy?: string | null;
                /** @description Whether `value` is decrypted. */
                decrypted?: boolean;
                edgeConfigId?: string | null;
                edgeConfigTokenId?: string | null;
                gitBranch?: string;
                id?: string;
                key: string;
                target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
                /** @enum {string} */
                type: "secret" | "system" | "encrypted" | "plain" | "sensitive";
                updatedAt?: number;
                updatedBy?: string | null;
                value: string;
              })[];
            /** @enum {string|null} */
            framework?: "blitzjs" | "nextjs" | "gatsby" | "remix" | "astro" | "hexo" | "eleventy" | "docusaurus-2" | "docusaurus" | "preact" | "solidstart" | "dojo" | "ember" | "vue" | "scully" | "ionic-angular" | "angular" | "polymer" | "svelte" | "sveltekit" | "sveltekit-1" | "ionic-react" | "create-react-app" | "gridsome" | "umijs" | "sapper" | "saber" | "stencil" | "nuxtjs" | "redwoodjs" | "hugo" | "jekyll" | "brunch" | "middleman" | "zola" | "hydrogen" | "vite" | "vitepress" | "vuepress" | "parcel" | "sanity";
            gitForkProtection?: boolean;
            hasFloatingAliases?: boolean;
            id: string;
            installCommand?: string | null;
            lastRollbackTarget?: ({
              fromDeploymentId: string;
              /** @enum {string} */
              jobStatus: "succeeded" | "failed" | "skipped" | "pending" | "in-progress";
              requestedAt: number;
              toDeploymentId: string;
            }) | null;
            latestDeployments?: ({
                alias?: string[];
                aliasAssigned?: number | boolean;
                aliasError?: {
                  code: string;
                  message: string;
                } | null;
                aliasFinal?: string | null;
                automaticAliases?: string[];
                buildingAt?: number;
                builds?: {
                    dest?: string;
                    src?: string;
                    use: string;
                  }[];
                /** @enum {string} */
                checksConclusion?: "succeeded" | "failed" | "skipped" | "canceled";
                /** @enum {string} */
                checksState?: "registered" | "running" | "completed";
                createdAt: number;
                createdIn: string;
                creator: {
                  email: string;
                  githubLogin?: string;
                  gitlabLogin?: string;
                  uid: string;
                  username: string;
                } | null;
                deploymentHostname: string;
                forced?: boolean;
                id: string;
                /** @description Construct a type with a set of properties K of type T */
                meta?: {
                  [key: string]: string;
                };
                monorepoManager?: string | null;
                name: string;
                /** @enum {string} */
                plan: "hobby" | "enterprise" | "pro" | "oss";
                /** @description Whether or not preview comments are enabled for the deployment */
                previewCommentsEnabled?: boolean;
                private: boolean;
                readyAt?: number;
                /** @enum {string} */
                readyState: "BUILDING" | "ERROR" | "INITIALIZING" | "QUEUED" | "READY" | "CANCELED";
                requestedAt?: number;
                target?: string | null;
                teamId?: string | null;
                /** @enum {string} */
                type: "LAMBDAS";
                url: string;
                userId: string;
                withCache?: boolean;
              })[];
            link?: OneOf<[{
              createdAt?: number;
              deployHooks: {
                  createdAt?: number;
                  id: string;
                  name: string;
                  ref: string;
                  url: string;
                }[];
              gitCredentialId?: string;
              org?: string;
              productionBranch?: string;
              repo?: string;
              repoId?: number;
              sourceless?: boolean;
              /** @enum {string} */
              type?: "github";
              updatedAt?: number;
            }, {
              createdAt?: number;
              deployHooks: {
                  createdAt?: number;
                  id: string;
                  name: string;
                  ref: string;
                  url: string;
                }[];
              gitCredentialId?: string;
              productionBranch?: string;
              projectId?: string;
              projectName?: string;
              projectNameWithNamespace?: string;
              projectNamespace?: string;
              projectUrl?: string;
              sourceless?: boolean;
              /** @enum {string} */
              type?: "gitlab";
              updatedAt?: number;
            }, {
              createdAt?: number;
              deployHooks: {
                  createdAt?: number;
                  id: string;
                  name: string;
                  ref: string;
                  url: string;
                }[];
              gitCredentialId?: string;
              name?: string;
              owner?: string;
              productionBranch?: string;
              slug?: string;
              sourceless?: boolean;
              /** @enum {string} */
              type?: "bitbucket";
              updatedAt?: number;
              uuid?: string;
              workspaceUuid?: string;
            }]>;
            live?: boolean;
            name: string;
            /** @enum {string} */
            nodeVersion: "18.x" | "16.x" | "14.x" | "12.x" | "10.x";
            outputDirectory?: string | null;
            passwordProtection?: ({
              /** @enum {string} */
              deploymentType: "preview" | "all";
            }) | null;
            permissions?: {
              Monitoring?: components["schemas"]["ACLAction"][];
              aliasGlobal?: components["schemas"]["ACLAction"][];
              aliasProject?: components["schemas"]["ACLAction"][];
              aliasProtectionBypass?: components["schemas"]["ACLAction"][];
              analytics?: components["schemas"]["ACLAction"][];
              analyticsSampling?: components["schemas"]["ACLAction"][];
              analyticsUsage?: components["schemas"]["ACLAction"][];
              auditLog?: components["schemas"]["ACLAction"][];
              awsBillingIntegration?: components["schemas"]["ACLAction"][];
              billingAddress?: components["schemas"]["ACLAction"][];
              billingInformation?: components["schemas"]["ACLAction"][];
              billingInvoice?: components["schemas"]["ACLAction"][];
              billingInvoiceEmailRecipient?: components["schemas"]["ACLAction"][];
              billingInvoiceLanguage?: components["schemas"]["ACLAction"][];
              billingPlan?: components["schemas"]["ACLAction"][];
              billingPurchaseOrder?: components["schemas"]["ACLAction"][];
              billingTaxId?: components["schemas"]["ACLAction"][];
              cacheArtifact?: components["schemas"]["ACLAction"][];
              cacheArtifactUsageEvent?: components["schemas"]["ACLAction"][];
              concurrentBuilds?: components["schemas"]["ACLAction"][];
              connect?: components["schemas"]["ACLAction"][];
              connectConfiguration?: components["schemas"]["ACLAction"][];
              connectConfigurationLink?: components["schemas"]["ACLAction"][];
              deployment?: components["schemas"]["ACLAction"][];
              deploymentCheck?: components["schemas"]["ACLAction"][];
              deploymentCheckPreview?: components["schemas"]["ACLAction"][];
              deploymentPreview?: components["schemas"]["ACLAction"][];
              deploymentPrivate?: components["schemas"]["ACLAction"][];
              deploymentProductionGit?: components["schemas"]["ACLAction"][];
              deploymentRollback?: components["schemas"]["ACLAction"][];
              domain?: components["schemas"]["ACLAction"][];
              domainAcceptDelegation?: components["schemas"]["ACLAction"][];
              domainAuthCodes?: components["schemas"]["ACLAction"][];
              domainCertificate?: components["schemas"]["ACLAction"][];
              domainCheckConfig?: components["schemas"]["ACLAction"][];
              domainMove?: components["schemas"]["ACLAction"][];
              domainPurchase?: components["schemas"]["ACLAction"][];
              domainRecord?: components["schemas"]["ACLAction"][];
              domainTransferIn?: components["schemas"]["ACLAction"][];
              edgeConfig?: components["schemas"]["ACLAction"][];
              edgeConfigItem?: components["schemas"]["ACLAction"][];
              edgeConfigToken?: components["schemas"]["ACLAction"][];
              endpointVerification?: components["schemas"]["ACLAction"][];
              event?: components["schemas"]["ACLAction"][];
              fileUpload?: components["schemas"]["ACLAction"][];
              gitRepository?: components["schemas"]["ACLAction"][];
              integration?: components["schemas"]["ACLAction"][];
              integrationConfiguration?: components["schemas"]["ACLAction"][];
              integrationConfigurationProjects?: components["schemas"]["ACLAction"][];
              integrationConfigurationTransfer?: components["schemas"]["ACLAction"][];
              integrationVercelConfigurationOverride?: components["schemas"]["ACLAction"][];
              job?: components["schemas"]["ACLAction"][];
              logDrain?: components["schemas"]["ACLAction"][];
              monitoringChart?: components["schemas"]["ACLAction"][];
              monitoringQuery?: components["schemas"]["ACLAction"][];
              notificationDomainConfiguration?: components["schemas"]["ACLAction"][];
              notificationDomainExpire?: components["schemas"]["ACLAction"][];
              notificationDomainMoved?: components["schemas"]["ACLAction"][];
              notificationDomainPurchase?: components["schemas"]["ACLAction"][];
              notificationDomainRenewal?: components["schemas"]["ACLAction"][];
              notificationDomainTransfer?: components["schemas"]["ACLAction"][];
              notificationDomainUnverified?: components["schemas"]["ACLAction"][];
              notificationPaymentFailed?: components["schemas"]["ACLAction"][];
              notificationSpendCap?: components["schemas"]["ACLAction"][];
              notificationUsageAlert?: components["schemas"]["ACLAction"][];
              openTelemetryEndpoint?: components["schemas"]["ACLAction"][];
              passwordProtection?: components["schemas"]["ACLAction"][];
              paymentMethod?: components["schemas"]["ACLAction"][];
              permissions?: components["schemas"]["ACLAction"][];
              previewDeploymentSuffix?: components["schemas"]["ACLAction"][];
              proTrialOnboarding?: components["schemas"]["ACLAction"][];
              project?: components["schemas"]["ACLAction"][];
              projectDeploymentHook?: components["schemas"]["ACLAction"][];
              projectDomain?: components["schemas"]["ACLAction"][];
              projectDomainMove?: components["schemas"]["ACLAction"][];
              projectEnvVars?: components["schemas"]["ACLAction"][];
              projectEnvVarsProduction?: components["schemas"]["ACLAction"][];
              projectEnvVarsUnownedByIntegration?: components["schemas"]["ACLAction"][];
              projectIntegrationConfiguration?: components["schemas"]["ACLAction"][];
              projectLink?: components["schemas"]["ACLAction"][];
              projectMember?: components["schemas"]["ACLAction"][];
              projectProductionBranch?: components["schemas"]["ACLAction"][];
              projectProtectionBypass?: components["schemas"]["ACLAction"][];
              projectTransfer?: components["schemas"]["ACLAction"][];
              rateLimit?: components["schemas"]["ACLAction"][];
              redis?: components["schemas"]["ACLAction"][];
              remoteCaching?: components["schemas"]["ACLAction"][];
              samlConfig?: components["schemas"]["ACLAction"][];
              secret?: components["schemas"]["ACLAction"][];
              sensitiveEnvironmentVariablePolicy?: components["schemas"]["ACLAction"][];
              sharedEnvVars?: components["schemas"]["ACLAction"][];
              sharedEnvVarsProduction?: components["schemas"]["ACLAction"][];
              spendCapConfiguration?: components["schemas"]["ACLAction"][];
              spendCapState?: components["schemas"]["ACLAction"][];
              supportCase?: components["schemas"]["ACLAction"][];
              supportCaseComment?: components["schemas"]["ACLAction"][];
              team?: components["schemas"]["ACLAction"][];
              teamAccessRequest?: components["schemas"]["ACLAction"][];
              teamFellowMembership?: components["schemas"]["ACLAction"][];
              teamInvite?: components["schemas"]["ACLAction"][];
              teamInviteCode?: components["schemas"]["ACLAction"][];
              teamJoin?: components["schemas"]["ACLAction"][];
              teamOwnMembership?: components["schemas"]["ACLAction"][];
              teamOwnMembershipDisconnectSAML?: components["schemas"]["ACLAction"][];
              token?: components["schemas"]["ACLAction"][];
              usage?: components["schemas"]["ACLAction"][];
              user?: components["schemas"]["ACLAction"][];
              userConnection?: components["schemas"]["ACLAction"][];
              webAnalytics?: components["schemas"]["ACLAction"][];
              webhook?: components["schemas"]["ACLAction"][];
              "webhook-event"?: components["schemas"]["ACLAction"][];
            };
            /** @description Construct a type with a set of properties K of type T */
            protectionBypass?: {
              [key: string]: string;
            };
            publicSource?: boolean | null;
            rootDirectory?: string | null;
            serverlessFunctionRegion?: string | null;
            skipGitConnectDuringLink?: boolean;
            sourceFilesOutsideRootDirectory?: boolean;
            ssoProtection?: ({
              /** @enum {string} */
              deploymentType: "preview" | "all";
            }) | null;
            /** @description An object containing the deployment's metadata */
            targets?: {
              [key: string]: string;
            };
            transferCompletedAt?: number;
            transferStartedAt?: number;
            transferToAccountId?: string;
            transferredFromAccountId?: string;
            updatedAt?: number;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The project could not be found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Delete a Project
   * @description Delete a specific project by passing either the project `id` or `name` in the URL.
   */
  deleteProject: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique project identifier or the project name */
        idOrName: string;
      };
    };
    responses: {
      /** @description The project was successfuly removed */
      204: {
        content: never;
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
      409: {
        content: never;
      };
    };
  };
  /**
   * Update an existing project
   * @description Update the fields of a project using either its `name` or `id`.
   */
  updateProject: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique project identifier or the project name */
        idOrName: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          autoExposeSystemEnvs?: boolean;
          /** @description The build command for this project. When `null` is used this value will be automatically detected */
          buildCommand?: string | null;
          commandForIgnoringBuildStep?: string | null;
          /** @description The dev command for this project. When `null` is used this value will be automatically detected */
          devCommand?: string | null;
          directoryListing?: boolean;
          /** @description Opt-in to Preview comments on the project level */
          enablePreviewFeedback?: boolean | null;
          /**
           * @description The framework that is being used for this project. When `null` is used no framework is selected
           * @enum {string|null}
           */
          framework?: null | "blitzjs" | "nextjs" | "gatsby" | "remix" | "astro" | "hexo" | "eleventy" | "docusaurus-2" | "docusaurus" | "preact" | "solidstart" | "dojo" | "ember" | "vue" | "scully" | "ionic-angular" | "angular" | "polymer" | "svelte" | "sveltekit" | "sveltekit-1" | "ionic-react" | "create-react-app" | "gridsome" | "umijs" | "sapper" | "saber" | "stencil" | "nuxtjs" | "redwoodjs" | "hugo" | "jekyll" | "brunch" | "middleman" | "zola" | "hydrogen" | "vite" | "vitepress" | "vuepress" | "parcel" | "sanity";
          /** @description Specifies whether PRs from Git forks should require a team member's authorization before it can be deployed */
          gitForkProtection?: boolean;
          /** @description The install command for this project. When `null` is used this value will be automatically detected */
          installCommand?: string | null;
          /** @description The desired name for the project */
          name?: string;
          /** @enum {string} */
          nodeVersion?: "18.x" | "16.x" | "14.x" | "12.x" | "10.x";
          /** @description The output directory of the project. When `null` is used this value will be automatically detected */
          outputDirectory?: string | null;
          /** @description Allows to protect project deployments with a password */
          passwordProtection?: ({
            /**
             * @description Specify if the password will apply to every Deployment Target or just Preview
             * @enum {string}
             */
            deploymentType: "all" | "preview";
            /** @description The password that will be used to protect Project Deployments */
            password?: string | null;
          }) | null;
          /** @description Specifies whether the source code and logs of the deployments for this project should be public or not */
          publicSource?: boolean | null;
          /** @description The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root */
          rootDirectory?: string | null;
          /** @description The region to deploy Serverless Functions in this project */
          serverlessFunctionRegion?: string | null;
          /**
           * @deprecated
           * @description Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.
           */
          skipGitConnectDuringLink?: boolean;
          /** @description Indicates if there are source files outside of the root directory */
          sourceFilesOutsideRootDirectory?: boolean;
          /** @description Ensures visitors to your Preview Deployments are logged into Vercel and have a minimum of Viewer access on your team */
          ssoProtection?: ({
            /**
             * @description Specify if the Vercel Authentication (SSO Protection) will apply to every Deployment Target or just Preview
             * @default preview
             * @enum {string}
             */
            deploymentType: "all" | "preview";
          }) | null;
        };
      };
    };
    responses: {
      /** @description The project was succesfuly updated */
      200: {
        content: {
          "application/json": {
            accountId: string;
            analytics?: {
              canceledAt: number | null;
              disabledAt: number;
              enabledAt: number;
              id: string;
              paidAt?: number;
              sampleRatePercent?: number | null;
              spendLimitInDollars?: number | null;
            };
            autoExposeSystemEnvs?: boolean;
            buildCommand?: string | null;
            commandForIgnoringBuildStep?: string | null;
            connectConfigurationId?: string | null;
            createdAt?: number;
            devCommand?: string | null;
            directoryListing: boolean;
            enablePreviewFeedback?: boolean | null;
            env?: ({
                configurationId?: string | null;
                createdAt?: number;
                createdBy?: string | null;
                /** @description Whether `value` is decrypted. */
                decrypted?: boolean;
                edgeConfigId?: string | null;
                edgeConfigTokenId?: string | null;
                gitBranch?: string;
                id?: string;
                key: string;
                target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
                /** @enum {string} */
                type: "secret" | "system" | "encrypted" | "plain" | "sensitive";
                updatedAt?: number;
                updatedBy?: string | null;
                value: string;
              })[];
            /** @enum {string|null} */
            framework?: "blitzjs" | "nextjs" | "gatsby" | "remix" | "astro" | "hexo" | "eleventy" | "docusaurus-2" | "docusaurus" | "preact" | "solidstart" | "dojo" | "ember" | "vue" | "scully" | "ionic-angular" | "angular" | "polymer" | "svelte" | "sveltekit" | "sveltekit-1" | "ionic-react" | "create-react-app" | "gridsome" | "umijs" | "sapper" | "saber" | "stencil" | "nuxtjs" | "redwoodjs" | "hugo" | "jekyll" | "brunch" | "middleman" | "zola" | "hydrogen" | "vite" | "vitepress" | "vuepress" | "parcel" | "sanity";
            gitForkProtection?: boolean;
            hasFloatingAliases?: boolean;
            id: string;
            installCommand?: string | null;
            lastRollbackTarget?: ({
              fromDeploymentId: string;
              /** @enum {string} */
              jobStatus: "succeeded" | "failed" | "skipped" | "pending" | "in-progress";
              requestedAt: number;
              toDeploymentId: string;
            }) | null;
            latestDeployments?: ({
                alias?: string[];
                aliasAssigned?: number | boolean;
                aliasError?: {
                  code: string;
                  message: string;
                } | null;
                aliasFinal?: string | null;
                automaticAliases?: string[];
                buildingAt?: number;
                builds?: {
                    dest?: string;
                    src?: string;
                    use: string;
                  }[];
                /** @enum {string} */
                checksConclusion?: "succeeded" | "failed" | "skipped" | "canceled";
                /** @enum {string} */
                checksState?: "registered" | "running" | "completed";
                createdAt: number;
                createdIn: string;
                creator: {
                  email: string;
                  githubLogin?: string;
                  gitlabLogin?: string;
                  uid: string;
                  username: string;
                } | null;
                deploymentHostname: string;
                forced?: boolean;
                id: string;
                /** @description Construct a type with a set of properties K of type T */
                meta?: {
                  [key: string]: string;
                };
                monorepoManager?: string | null;
                name: string;
                /** @enum {string} */
                plan: "hobby" | "enterprise" | "pro" | "oss";
                /** @description Whether or not preview comments are enabled for the deployment */
                previewCommentsEnabled?: boolean;
                private: boolean;
                readyAt?: number;
                /** @enum {string} */
                readyState: "BUILDING" | "ERROR" | "INITIALIZING" | "QUEUED" | "READY" | "CANCELED";
                requestedAt?: number;
                target?: string | null;
                teamId?: string | null;
                /** @enum {string} */
                type: "LAMBDAS";
                url: string;
                userId: string;
                withCache?: boolean;
              })[];
            link?: OneOf<[{
              createdAt?: number;
              deployHooks: {
                  createdAt?: number;
                  id: string;
                  name: string;
                  ref: string;
                  url: string;
                }[];
              gitCredentialId?: string;
              org?: string;
              productionBranch?: string;
              repo?: string;
              repoId?: number;
              sourceless?: boolean;
              /** @enum {string} */
              type?: "github";
              updatedAt?: number;
            }, {
              createdAt?: number;
              deployHooks: {
                  createdAt?: number;
                  id: string;
                  name: string;
                  ref: string;
                  url: string;
                }[];
              gitCredentialId?: string;
              productionBranch?: string;
              projectId?: string;
              projectName?: string;
              projectNameWithNamespace?: string;
              projectNamespace?: string;
              projectUrl?: string;
              sourceless?: boolean;
              /** @enum {string} */
              type?: "gitlab";
              updatedAt?: number;
            }, {
              createdAt?: number;
              deployHooks: {
                  createdAt?: number;
                  id: string;
                  name: string;
                  ref: string;
                  url: string;
                }[];
              gitCredentialId?: string;
              name?: string;
              owner?: string;
              productionBranch?: string;
              slug?: string;
              sourceless?: boolean;
              /** @enum {string} */
              type?: "bitbucket";
              updatedAt?: number;
              uuid?: string;
              workspaceUuid?: string;
            }]>;
            live?: boolean;
            name: string;
            /** @enum {string} */
            nodeVersion: "18.x" | "16.x" | "14.x" | "12.x" | "10.x";
            outputDirectory?: string | null;
            passwordProtection?: ({
              /** @enum {string} */
              deploymentType: "all" | "preview";
            }) | null;
            permissions?: {
              Monitoring?: components["schemas"]["ACLAction"][];
              aliasGlobal?: components["schemas"]["ACLAction"][];
              aliasProject?: components["schemas"]["ACLAction"][];
              aliasProtectionBypass?: components["schemas"]["ACLAction"][];
              analytics?: components["schemas"]["ACLAction"][];
              analyticsSampling?: components["schemas"]["ACLAction"][];
              analyticsUsage?: components["schemas"]["ACLAction"][];
              auditLog?: components["schemas"]["ACLAction"][];
              awsBillingIntegration?: components["schemas"]["ACLAction"][];
              billingAddress?: components["schemas"]["ACLAction"][];
              billingInformation?: components["schemas"]["ACLAction"][];
              billingInvoice?: components["schemas"]["ACLAction"][];
              billingInvoiceEmailRecipient?: components["schemas"]["ACLAction"][];
              billingInvoiceLanguage?: components["schemas"]["ACLAction"][];
              billingPlan?: components["schemas"]["ACLAction"][];
              billingPurchaseOrder?: components["schemas"]["ACLAction"][];
              billingTaxId?: components["schemas"]["ACLAction"][];
              cacheArtifact?: components["schemas"]["ACLAction"][];
              cacheArtifactUsageEvent?: components["schemas"]["ACLAction"][];
              concurrentBuilds?: components["schemas"]["ACLAction"][];
              connect?: components["schemas"]["ACLAction"][];
              connectConfiguration?: components["schemas"]["ACLAction"][];
              connectConfigurationLink?: components["schemas"]["ACLAction"][];
              deployment?: components["schemas"]["ACLAction"][];
              deploymentCheck?: components["schemas"]["ACLAction"][];
              deploymentCheckPreview?: components["schemas"]["ACLAction"][];
              deploymentPreview?: components["schemas"]["ACLAction"][];
              deploymentPrivate?: components["schemas"]["ACLAction"][];
              deploymentProductionGit?: components["schemas"]["ACLAction"][];
              deploymentRollback?: components["schemas"]["ACLAction"][];
              domain?: components["schemas"]["ACLAction"][];
              domainAcceptDelegation?: components["schemas"]["ACLAction"][];
              domainAuthCodes?: components["schemas"]["ACLAction"][];
              domainCertificate?: components["schemas"]["ACLAction"][];
              domainCheckConfig?: components["schemas"]["ACLAction"][];
              domainMove?: components["schemas"]["ACLAction"][];
              domainPurchase?: components["schemas"]["ACLAction"][];
              domainRecord?: components["schemas"]["ACLAction"][];
              domainTransferIn?: components["schemas"]["ACLAction"][];
              edgeConfig?: components["schemas"]["ACLAction"][];
              edgeConfigItem?: components["schemas"]["ACLAction"][];
              edgeConfigToken?: components["schemas"]["ACLAction"][];
              endpointVerification?: components["schemas"]["ACLAction"][];
              event?: components["schemas"]["ACLAction"][];
              fileUpload?: components["schemas"]["ACLAction"][];
              gitRepository?: components["schemas"]["ACLAction"][];
              integration?: components["schemas"]["ACLAction"][];
              integrationConfiguration?: components["schemas"]["ACLAction"][];
              integrationConfigurationProjects?: components["schemas"]["ACLAction"][];
              integrationConfigurationTransfer?: components["schemas"]["ACLAction"][];
              integrationVercelConfigurationOverride?: components["schemas"]["ACLAction"][];
              job?: components["schemas"]["ACLAction"][];
              logDrain?: components["schemas"]["ACLAction"][];
              monitoringChart?: components["schemas"]["ACLAction"][];
              monitoringQuery?: components["schemas"]["ACLAction"][];
              notificationDomainConfiguration?: components["schemas"]["ACLAction"][];
              notificationDomainExpire?: components["schemas"]["ACLAction"][];
              notificationDomainMoved?: components["schemas"]["ACLAction"][];
              notificationDomainPurchase?: components["schemas"]["ACLAction"][];
              notificationDomainRenewal?: components["schemas"]["ACLAction"][];
              notificationDomainTransfer?: components["schemas"]["ACLAction"][];
              notificationDomainUnverified?: components["schemas"]["ACLAction"][];
              notificationPaymentFailed?: components["schemas"]["ACLAction"][];
              notificationSpendCap?: components["schemas"]["ACLAction"][];
              notificationUsageAlert?: components["schemas"]["ACLAction"][];
              openTelemetryEndpoint?: components["schemas"]["ACLAction"][];
              passwordProtection?: components["schemas"]["ACLAction"][];
              paymentMethod?: components["schemas"]["ACLAction"][];
              permissions?: components["schemas"]["ACLAction"][];
              previewDeploymentSuffix?: components["schemas"]["ACLAction"][];
              proTrialOnboarding?: components["schemas"]["ACLAction"][];
              project?: components["schemas"]["ACLAction"][];
              projectDeploymentHook?: components["schemas"]["ACLAction"][];
              projectDomain?: components["schemas"]["ACLAction"][];
              projectDomainMove?: components["schemas"]["ACLAction"][];
              projectEnvVars?: components["schemas"]["ACLAction"][];
              projectEnvVarsProduction?: components["schemas"]["ACLAction"][];
              projectEnvVarsUnownedByIntegration?: components["schemas"]["ACLAction"][];
              projectIntegrationConfiguration?: components["schemas"]["ACLAction"][];
              projectLink?: components["schemas"]["ACLAction"][];
              projectMember?: components["schemas"]["ACLAction"][];
              projectProductionBranch?: components["schemas"]["ACLAction"][];
              projectProtectionBypass?: components["schemas"]["ACLAction"][];
              projectTransfer?: components["schemas"]["ACLAction"][];
              rateLimit?: components["schemas"]["ACLAction"][];
              redis?: components["schemas"]["ACLAction"][];
              remoteCaching?: components["schemas"]["ACLAction"][];
              samlConfig?: components["schemas"]["ACLAction"][];
              secret?: components["schemas"]["ACLAction"][];
              sensitiveEnvironmentVariablePolicy?: components["schemas"]["ACLAction"][];
              sharedEnvVars?: components["schemas"]["ACLAction"][];
              sharedEnvVarsProduction?: components["schemas"]["ACLAction"][];
              spendCapConfiguration?: components["schemas"]["ACLAction"][];
              spendCapState?: components["schemas"]["ACLAction"][];
              supportCase?: components["schemas"]["ACLAction"][];
              supportCaseComment?: components["schemas"]["ACLAction"][];
              team?: components["schemas"]["ACLAction"][];
              teamAccessRequest?: components["schemas"]["ACLAction"][];
              teamFellowMembership?: components["schemas"]["ACLAction"][];
              teamInvite?: components["schemas"]["ACLAction"][];
              teamInviteCode?: components["schemas"]["ACLAction"][];
              teamJoin?: components["schemas"]["ACLAction"][];
              teamOwnMembership?: components["schemas"]["ACLAction"][];
              teamOwnMembershipDisconnectSAML?: components["schemas"]["ACLAction"][];
              token?: components["schemas"]["ACLAction"][];
              usage?: components["schemas"]["ACLAction"][];
              user?: components["schemas"]["ACLAction"][];
              userConnection?: components["schemas"]["ACLAction"][];
              webAnalytics?: components["schemas"]["ACLAction"][];
              webhook?: components["schemas"]["ACLAction"][];
              "webhook-event"?: components["schemas"]["ACLAction"][];
            };
            /** @description Construct a type with a set of properties K of type T */
            protectionBypass?: {
              [key: string]: string;
            };
            publicSource?: boolean | null;
            rootDirectory?: string | null;
            serverlessFunctionRegion?: string | null;
            skipGitConnectDuringLink?: boolean;
            sourceFilesOutsideRootDirectory?: boolean;
            ssoProtection?: ({
              /** @enum {string} */
              deploymentType: "all" | "preview";
            }) | null;
            /** @description An object containing the deployment's metadata */
            targets?: {
              [key: string]: string;
            };
            transferCompletedAt?: number;
            transferStartedAt?: number;
            transferToAccountId?: string;
            transferredFromAccountId?: string;
            updatedAt?: number;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       * Owner does not have protection add-on
       * Advanced Deployment Protection is not available for the user plan
       */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The project was not found */
      404: {
        content: never;
      };
      /**
       * @description The provided name for the project is already being used
       * The project is currently being transferred.
       */
      409: {
        content: never;
      };
    };
  };
  /**
   * Retrieve project domains by project by id or name
   * @description Retrieve the domains associated with a given project by passing either the project `id` or `name` in the URL.
   */
  getProjectDomains: {
    parameters: {
      query?: {
        /** @description Filters only production domains when set to `true`. */
        production?: "true" | "false";
        /** @description Filters domains based on specific branch. */
        gitBranch?: string;
        /** @description Excludes redirect project domains when \"false\". Includes redirect project domains when \"true\" (default). */
        redirects?: "true" | "false";
        /** @description Filters domains based on their redirect target. */
        redirect?: string;
        /** @description Filters domains based on their verification status. */
        verified?: "true" | "false";
        /** @description Maximum number of domains to list from a request (max 100). */
        limit?: number;
        /** @description Get domains created after this JavaScript timestamp. */
        since?: number;
        /** @description Get domains created before this JavaScript timestamp. */
        until?: number;
        /** @description Domains sort order by createdAt */
        order?: "ASC" | "DESC";
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique project identifier or the project name */
        idOrName: string | number;
      };
    };
    responses: {
      /** @description Successful response retrieving a list of domains */
      200: {
        content: {
          "application/json": {
            domains: ({
                apexName: string;
                createdAt?: number;
                gitBranch?: string | null;
                name: string;
                projectId: string;
                redirect?: string | null;
                /** @enum {number|null} */
                redirectStatusCode?: 307 | 301 | 302 | 308;
                updatedAt?: number;
                /** @description A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`. */
                verification?: {
                    domain: string;
                    reason: string;
                    type: string;
                    value: string;
                  }[];
                /** @description `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed. */
                verified: boolean;
              })[];
            pagination: components["schemas"]["Pagination"];
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description Project not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Add a domain to a project
   * @description Add a domain to the project by passing its domain name and by specifying the project by either passing the project `id` or `name` in the URL. If the domain is not yet verified to be used on this project, the request will return `verified = false`, and the domain will need to be verified according to the `verification` challenge via `POST /projects/:idOrName/domains/:domain/verify`. If the domain already exists on the project, the request will fail with a `400` status code.
   */
  addProjectDomain: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique project identifier or the project name */
        idOrName: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description Git branch to link the project domain */
          gitBranch?: string | null;
          /** @description The project domain name */
          name: string;
          /** @description Target destination domain for redirect */
          redirect?: string | null;
          /**
           * @description Status code for domain redirect
           * @enum {integer|null}
           */
          redirectStatusCode?: null | 301 | 302 | 307 | 308;
        };
      };
    };
    responses: {
      /** @description The domain was successfully added to the project */
      200: {
        content: {
          "application/json": {
            apexName: string;
            createdAt?: number;
            gitBranch?: string | null;
            name: string;
            projectId: string;
            redirect?: string | null;
            /** @enum {number|null} */
            redirectStatusCode?: 307 | 301 | 302 | 308;
            updatedAt?: number;
            /** @description A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`. */
            verification?: {
                domain: string;
                reason: string;
                type: string;
                value: string;
              }[];
            /** @description `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed. */
            verified: boolean;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       * The domain is not valid
       * You can't set both a git branch and a redirect for the domain
       * The domain can not be added because the latest production deployment for the project was not successful
       * The domain redirect is not valid
       * A domain cannot redirect to itself
       * You can not set the production branch as a branch for your domain
       */
      400: {
        content: never;
      };
      /**
       * @description The account was soft-blocked for an unhandled reason.
       * The account is missing a payment so payment method must be updated
       */
      402: {
        content: never;
      };
      /**
       * @description You do not have permission to access this resource.
       * You don't have access to the domain you are adding
       */
      403: {
        content: never;
      };
      /** @description Project not found */
      404: {
        content: never;
      };
      /**
       * @description The domain is already assigned to another Vercel project
       * Cannot create project domain since owner already has `domain` on their account
       * Cannot create project domain if the current verified domain
       * The project is currently being transferred
       */
      409: {
        content: never;
      };
    };
  };
  /**
   * Get a project domain
   * @description Get project domain by project id/name and domain name.
   */
  getProjectDomain: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique project identifier or the project name */
        idOrName: string;
        /** @description The project domain name */
        domain: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            apexName: string;
            createdAt?: number;
            gitBranch?: string | null;
            name: string;
            projectId: string;
            redirect?: string | null;
            /** @enum {number|null} */
            redirectStatusCode?: 307 | 301 | 302 | 308;
            updatedAt?: number;
            /** @description A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`. */
            verification?: {
                domain: string;
                reason: string;
                type: string;
                value: string;
              }[];
            /** @description `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed. */
            verified: boolean;
          };
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description Project not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Remove a domain from a project
   * @description Remove a domain from a project by passing the domain name and by specifying the project by either passing the project `id` or `name` in the URL.
   */
  removeProjectDomain: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique project identifier or the project name */
        idOrName: string;
        /** @description The project domain name */
        domain: string;
      };
    };
    responses: {
      /** @description The domain was succesfully removed from the project */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description Project not found */
      404: {
        content: never;
      };
      /** @description The project is currently being transferred */
      409: {
        content: never;
      };
    };
  };
  /**
   * Update a project domain
   * @description Update a project domain's configuration, including the name, git branch and redirect of the domain.
   */
  updateProjectDomain: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique project identifier or the project name */
        idOrName: string;
        /** @description The project domain name */
        domain: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description Git branch to link the project domain */
          gitBranch?: string | null;
          /** @description Target destination domain for redirect */
          redirect?: string | null;
          /**
           * @description Status code for domain redirect
           * @enum {integer|null}
           */
          redirectStatusCode?: null | 301 | 302 | 307 | 308;
        };
      };
    };
    responses: {
      /** @description The domain was updated successfuly */
      200: {
        content: {
          "application/json": {
            apexName: string;
            createdAt?: number;
            gitBranch?: string | null;
            name: string;
            projectId: string;
            redirect?: string | null;
            /** @enum {number|null} */
            redirectStatusCode?: 307 | 301 | 302 | 308;
            updatedAt?: number;
            /** @description A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`. */
            verification?: {
                domain: string;
                reason: string;
                type: string;
                value: string;
              }[];
            /** @description `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed. */
            verified: boolean;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       * The domain redirect is not valid
       */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The project was not found */
      404: {
        content: never;
      };
      /** @description The project is currently being transferred */
      409: {
        content: never;
      };
    };
  };
  /**
   * Verify project domain
   * @description Attempts to verify a project domain with `verified = false` by checking the correctness of the project domain's `verification` challenge.
   */
  verifyProjectDomain: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique project identifier or the project name */
        idOrName: string;
        /** @description The domain name you want to verify */
        domain: string;
      };
    };
    responses: {
      /**
       * @description The project domain was verified successfully
       * Domain is already verified
       */
      200: {
        content: {
          "application/json": {
            apexName: string;
            createdAt?: number;
            gitBranch?: string | null;
            name: string;
            projectId: string;
            redirect?: string | null;
            /** @enum {number|null} */
            redirectStatusCode?: 307 | 301 | 302 | 308;
            updatedAt?: number;
            /** @description A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`. */
            verification?: {
                domain: string;
                reason: string;
                type: string;
                value: string;
              }[];
            /** @description `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed. */
            verified: boolean;
          };
        };
      };
      /**
       * @description One of the provided values in the request query is invalid.
       * There is an existing TXT record on the domain verifying it for another project
       * The domain does not have a TXT record that attempts to verify the project domain
       * The TXT record on the domain does not match the expected challenge for the project domain
       * Project domain is not assigned to project
       * Project domain does not exist
       */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Retrieve the environment variables of a project by id or name
   * @description Retrieve the environment variables for a given project by passing either the project `id` or `name` in the URL.
   */
  filterProjectEnvs: {
    parameters: {
      query?: {
        /** @description If defined, the git branch of the environment variable to filter the results */
        gitBranch?: string;
        /** @description If true, the environment variable value will be decrypted */
        decrypt?: "true" | "false";
        /** @description The source that is calling the endpoint. */
        source?: string;
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique project identifier or the project name */
        idOrName: string;
      };
    };
    responses: {
      /** @description The list of environment variables for the given project */
      200: {
        content: {
          "application/json": OneOf<[{
            configurationId?: string | null;
            createdAt?: number;
            createdBy?: string | null;
            /** @description Whether `value` is decrypted. */
            decrypted?: boolean;
            edgeConfigId?: string | null;
            edgeConfigTokenId?: string | null;
            gitBranch?: string;
            id?: string;
            key?: string;
            system?: boolean;
            target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
            /** @enum {string} */
            type?: "secret" | "system" | "encrypted" | "plain" | "sensitive";
            updatedAt?: number;
            updatedBy?: string | null;
            value?: string;
          }, {
            envs: ({
                configurationId?: string | null;
                createdAt?: number;
                createdBy?: string | null;
                /** @description Whether `value` is decrypted. */
                decrypted?: boolean;
                edgeConfigId?: string | null;
                edgeConfigTokenId?: string | null;
                gitBranch?: string;
                id?: string;
                key?: string;
                system?: boolean;
                target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
                /** @enum {string} */
                type?: "secret" | "system" | "encrypted" | "plain" | "sensitive";
                updatedAt?: number;
                updatedBy?: string | null;
                value?: string;
              })[];
            pagination: components["schemas"]["Pagination"];
          }, {
            envs: ({
                configurationId?: string | null;
                createdAt?: number;
                createdBy?: string | null;
                /** @description Whether `value` is decrypted. */
                decrypted?: boolean;
                edgeConfigId?: string | null;
                edgeConfigTokenId?: string | null;
                gitBranch?: string;
                id?: string;
                key?: string;
                system?: boolean;
                target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
                /** @enum {string} */
                type?: "secret" | "system" | "encrypted" | "plain" | "sensitive";
                updatedAt?: number;
                updatedBy?: string | null;
                value?: string;
              })[];
          }]>;
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /** @description The project could not be found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Remove an environment variable
   * @description Delete a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL.
   */
  removeProjectEnv: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique project identifier or the project name */
        idOrName: string;
        /** @description The unique environment variable identifier */
        id: string;
      };
    };
    responses: {
      /** @description The environment variable was successfully removed */
      200: {
        content: {
          "application/json": OneOf<[({
              configurationId?: string | null;
              createdAt?: number;
              createdBy?: string | null;
              /** @description Whether `value` is decrypted. */
              decrypted?: boolean;
              edgeConfigId?: string | null;
              edgeConfigTokenId?: string | null;
              gitBranch?: string;
              id?: string;
              key: string;
              target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
              /** @enum {string} */
              type: "secret" | "system" | "encrypted" | "plain" | "sensitive";
              updatedAt?: number;
              updatedBy?: string | null;
              value: string;
            })[], {
            configurationId?: string | null;
            createdAt?: number;
            createdBy?: string | null;
            /** @description Whether `value` is decrypted. */
            decrypted?: boolean;
            edgeConfigId?: string | null;
            edgeConfigTokenId?: string | null;
            gitBranch?: string;
            id?: string;
            key: string;
            system?: boolean;
            target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
            /** @enum {string} */
            type: "secret" | "system" | "encrypted" | "plain" | "sensitive";
            updatedAt?: number;
            updatedBy?: string | null;
            value: string;
          }, {
            configurationId?: string | null;
            createdAt?: number;
            createdBy?: string | null;
            /** @description Whether `value` is decrypted. */
            decrypted?: boolean;
            edgeConfigId?: string | null;
            edgeConfigTokenId?: string | null;
            gitBranch?: string;
            id?: string;
            key: string;
            target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
            /** @enum {string} */
            type: "secret" | "system" | "encrypted" | "plain" | "sensitive";
            updatedAt?: number;
            updatedBy?: string | null;
            value: string;
          }]>;
        };
      };
      /** @description One of the provided values in the request query is invalid. */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /**
       * @description The environment variable could not be found
       * The project could not be found
       */
      404: {
        content: never;
      };
      /** @description The project is being transfered and removing an environment variable is not possible */
      409: {
        content: never;
      };
    };
  };
  /**
   * Edit an environment variable
   * @description Edit a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL.
   */
  editProjectEnv: {
    parameters: {
      query?: {
        /** @description The Team identifier or slug to perform the request on behalf of. */
        teamId?: string;
      };
      path: {
        /** @description The unique project identifier or the project name */
        idOrName: string;
        /** @description The unique environment variable identifier */
        id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description The git branch of the environment variable */
          gitBranch?: string | null;
          /** @description The name of the environment variable */
          key?: string;
          /** @description The target environment of the environment variable */
          target?: ("mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Productio" | "mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Previe" | "mport(\"/vercel/path0/utils/env-variable-util/types\").EnvTarget.Developmen")[];
          /**
           * @description The type of environment variable
           * @enum {string}
           */
          type?: "system" | "secret" | "encrypted" | "plain" | "sensitive";
          /** @description The value of the environment variable */
          value?: string;
        };
      };
    };
    responses: {
      /** @description The environment variable was successfully edited */
      200: {
        content: {
          "application/json": {
            configurationId?: string | null;
            createdAt?: number;
            createdBy?: string | null;
            /** @description Whether `value` is decrypted. */
            decrypted?: boolean;
            edgeConfigId?: string | null;
            edgeConfigTokenId?: string | null;
            gitBranch?: string;
            id?: string;
            key: string;
            target?: (("production" | "preview" | "development")[]) | ("production" | "preview" | "development");
            /** @enum {string} */
            type: "system" | "encrypted" | "plain" | "sensitive" | "secret";
            updatedAt?: number;
            updatedBy?: string | null;
            value: string;
          };
        };
      };
      /**
       * @description One of the provided values in the request body is invalid.
       * One of the provided values in the request query is invalid.
       */
      400: {
        content: never;
      };
      /** @description You do not have permission to access this resource. */
      403: {
        content: never;
      };
      /**
       * @description The environment variable could not be found
       * The project could not be found
       */
      404: {
        content: never;
      };
      /** @description The project is being transfered and removing an environment variable is not possible */
      409: {
        content: never;
      };
    };
  };
}
